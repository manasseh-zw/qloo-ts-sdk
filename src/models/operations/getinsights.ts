/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { RFCDate } from "../../types/rfcdate.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Filter by the category of entity to return (urn:entity:place).
 */
export const FilterType = {
  UrnEntityArtist: "urn:entity:artist",
  UrnEntityBook: "urn:entity:book",
  UrnEntityBrand: "urn:entity:brand",
  UrnEntityDestination: "urn:entity:destination",
  UrnEntityMovie: "urn:entity:movie",
  UrnEntityPerson: "urn:entity:person",
  UrnEntityPlace: "urn:entity:place",
  UrnEntityPodcast: "urn:entity:podcast",
  UrnEntityTvShow: "urn:entity:tv_show",
  UrnEntityVideogame: "urn:entity:videogame",
  UrnHeatmap: "urn:heatmap",
} as const;
/**
 * Filter by the category of entity to return (urn:entity:place).
 */
export type FilterType = ClosedEnum<typeof FilterType>;

/**
 * The level of impact a trending entity has on the results. Supported by select categories only.
 */
export const BiasTrends = {
  Off: "off",
  Low: "low",
  Medium: "medium",
  High: "high",
} as const;
/**
 * The level of impact a trending entity has on the results. Supported by select categories only.
 */
export type BiasTrends = ClosedEnum<typeof BiasTrends>;

/**
 * Filter by a comma-separated list of content ratings based on the MPAA film rating system, which determines suitability for various audiences.
 */
export const FilterContentRating = {
  G: "G",
  Pg: "PG",
  Pg13: "PG-13",
  R: "R",
  Nc17: "NC-17",
} as const;
/**
 * Filter by a comma-separated list of content ratings based on the MPAA film rating system, which determines suitability for various audiences.
 */
export type FilterContentRating = ClosedEnum<typeof FilterContentRating>;

/**
 * Specifies how multiple `filter.exclude.tags` values are combined in the query. Use "union" (equivalent to a logical "or") to exclude results that contain at least one of the specified tags, or "intersection" (equivalent to a logical "and") to exclude only results that contain all specified tags. The default is "union".
 */
export const OperatorExcludeTags = {
  Union: "union",
  Intersection: "intersection",
} as const;
/**
 * Specifies how multiple `filter.exclude.tags` values are combined in the query. Use "union" (equivalent to a logical "or") to exclude results that contain at least one of the specified tags, or "intersection" (equivalent to a logical "and") to exclude only results that contain all specified tags. The default is "union".
 */
export type OperatorExcludeTags = ClosedEnum<typeof OperatorExcludeTags>;

/**
 * Specifies how multiple `filter.external.exists` values are combined in the query. Use "union" (equivalent to a logical "or") to return results that match at least one of the specified external keys (e.g., resy, michelin, or tablet), or "intersection" (equivalent to a logical "and") to return only results that match all specified external keys. The default is "union".
 */
export const OperatorFilterExternalExists = {
  Union: "union",
  Intersection: "intersection",
} as const;
/**
 * Specifies how multiple `filter.external.exists` values are combined in the query. Use "union" (equivalent to a logical "or") to return results that match at least one of the specified external keys (e.g., resy, michelin, or tablet), or "intersection" (equivalent to a logical "and") to return only results that match all specified external keys. The default is "union".
 */
export type OperatorFilterExternalExists = ClosedEnum<
  typeof OperatorFilterExternalExists
>;

/**
 * Filter by the day of the week the Point of Interest must be open (Monday, Tuesday, etc.).
 */
export const FilterHours = {
  Monday: "monday",
  Tuesday: "tuesday",
  Wednesday: "wednesday",
  Thursday: "thursday",
  Friday: "friday",
  Saturday: "saturday",
  Sunday: "sunday",
} as const;
/**
 * Filter by the day of the week the Point of Interest must be open (Monday, Tuesday, etc.).
 */
export type FilterHours = ClosedEnum<typeof FilterHours>;

/**
 * A query used to search for one or more named `urn:entity:locality` Qloo IDs for filtering requests, equivalent to passing the same Locality Qloo ID(s) into `filter.location`.
 *
 * @remarks
 *   - For **GET requests**: Provide a single locality query as a string.
 *   - For **POST requests**:
 *     - You can still send a single locality as a string.
 *     - Or you can send an array of locality names to query multiple localities at once. When multiple localities are provided, their geographic shapes are merged, and the system returns results with the highest affinities across the combined area.
 *
 * Locality queries are fuzzy-matched and case-insensitive. Examples include `New York City`, `Garden City`, `New York`, `Los Angeles`, `Lower East Side`, and AKAs like `The Big Apple`. When a single locality is supplied, the response JSON includes `query.locality.signal` with the matched Qloo entity. If multiple are supplied, this field is omitted. By default, the API includes a tuning that also captures nearby entities just outside the official boundaries of the locality. To turn this off and limit results strictly to within the locality, set `filter.location.radius=0`. If no localities are found, the API returns a 400 error.
 */
export type FilterLocationQuery = string | Array<string>;

/**
 * A query used to exclude results based on one or more named `urn:entity:locality` Qloo IDs, resolved from fuzzy-matched locality names.   This is equivalent to passing the resolved Locality Qloo ID(s) into `filter.exclude.location`.
 *
 * @remarks
 * - For **GET requests**: Provide a single locality query as a string. - For **POST requests**:
 *   - You can still send a single locality as a string.
 *   - Or send an array of locality names to exclude multiple areas at once. When multiple localities are provided, their geographic shapes are merged, and the system excludes results from across the combined area.
 *
 * Locality queries are case-insensitive and support common AKAs (e.g., `The Big Apple` for New York).   When a single locality is supplied, the response includes `query.locality.exclude.signal` with the matched Qloo entity.   If multiple are supplied, this field is omitted. If no localities are matched, the API returns a 400 error.
 */
export type FilterExcludeLocationQuery = string | Array<string>;

/**
 * Specifies how multiple `filter.release_country`` values are combined in the query. Use "union" (equivalent to a logical "or") to return results that match at least one of the specified countries, or "intersection" (equivalent to a logical "and") to return only results that match all specified countries. The default is "union".
 */
export const OperatorFilterReleaseCountry = {
  Intersection: "intersection",
  Union: "union",
} as const;
/**
 * Specifies how multiple `filter.release_country`` values are combined in the query. Use "union" (equivalent to a logical "or") to return results that match at least one of the specified countries, or "intersection" (equivalent to a logical "and") to return only results that match all specified countries. The default is "union".
 */
export type OperatorFilterReleaseCountry = ClosedEnum<
  typeof OperatorFilterReleaseCountry
>;

/**
 * Search for one or more entities by name to use as filters.   - For **GET requests**: Provide a single entity name as a string. - For **POST requests**: You can provide a single name or an array of names.
 *
 * @remarks
 */
export type FilterResultsEntitiesQuery = string | Array<string>;

export type FilterExcludeEntitiesQuery = {
  name?: string | undefined;
  address?: string | undefined;
};

export type FilterExcludeEntitiesQueryUnion =
  | FilterExcludeEntitiesQuery
  | string;

/**
 * Specifies how multiple `filter.tags` values are combined in the query. Use "union" (equivalent to a logical "or") to return results that match at least one of the specified tags, or "intersection" (equivalent to a logical "and") to return only results that match all specified tags. The default is "union".
 */
export const OperatorFilterTags = {
  Union: "union",
  Intersection: "intersection",
} as const;
/**
 * Specifies how multiple `filter.tags` values are combined in the query. Use "union" (equivalent to a logical "or") to return results that match at least one of the specified tags, or "intersection" (equivalent to a logical "and") to return only results that match all specified tags. The default is "union".
 */
export type OperatorFilterTags = ClosedEnum<typeof OperatorFilterTags>;

/**
 * A comma-separated list of age ranges that influence the affinity score.(35_and_younger\|36_to_55\|55_and_older).
 */
export const SignalDemographicsAge = {
  ThirtyFiveAndYounger: "35_and_younger",
  ThirtySixTo55: "36_to_55",
  FiftyFiveAndOlder: "55_and_older",
} as const;
/**
 * A comma-separated list of age ranges that influence the affinity score.(35_and_younger\|36_to_55\|55_and_older).
 */
export type SignalDemographicsAge = ClosedEnum<typeof SignalDemographicsAge>;

export const SignalDemographicsAgeWeightEnum = {
  VeryLow: "very_low",
  Low: "low",
  Mid: "mid",
  Medium: "medium",
  High: "high",
  VeryHigh: "very_high",
} as const;
export type SignalDemographicsAgeWeightEnum = ClosedEnum<
  typeof SignalDemographicsAgeWeightEnum
>;

/**
 * Specifies the extent to which results should be influenced by age-based demographic signals. Higher values increase the influence of age data; lower values reduce its impact.
 */
export type SignalDemographicsAgeWeight =
  | number
  | SignalDemographicsAgeWeightEnum;

export const SignalDemographicsAudiencesWeightEnum = {
  VeryLow: "very_low",
  Low: "low",
  Mid: "mid",
  Medium: "medium",
  High: "high",
  VeryHigh: "very_high",
} as const;
export type SignalDemographicsAudiencesWeightEnum = ClosedEnum<
  typeof SignalDemographicsAudiencesWeightEnum
>;

/**
 * Specifies the extent to which results should be influenced by the preferences of the selected audience. Higher values increase the influence of audience preferences; lower values reduce their impact.
 */
export type SignalDemographicsAudiencesWeight =
  | number
  | SignalDemographicsAudiencesWeightEnum;

/**
 * Influence the affinity score based on gender (male\|female).
 */
export const SignalDemographicsGender = {
  Male: "male",
  Female: "female",
} as const;
/**
 * Influence the affinity score based on gender (male\|female).
 */
export type SignalDemographicsGender = ClosedEnum<
  typeof SignalDemographicsGender
>;

export const SignalDemographicsGenderWeightEnum = {
  VeryLow: "very_low",
  Low: "low",
  Mid: "mid",
  Medium: "medium",
  High: "high",
  VeryHigh: "very_high",
} as const;
export type SignalDemographicsGenderWeightEnum = ClosedEnum<
  typeof SignalDemographicsGenderWeightEnum
>;

/**
 * Specifies the extent to which results should be influenced by gender-based demographic signals. Higher values increase the influence of gender data; lower values reduce its impact.
 */
export type SignalDemographicsGenderWeight =
  | number
  | SignalDemographicsGenderWeightEnum;

export type SignalInterestsEntitiesQuery = {
  name?: string | undefined;
  address?: string | undefined;
};

export type SignalInterestsEntitiesQueryUnion =
  | SignalInterestsEntitiesQuery
  | string;

export const SignalInterestsEntitiesWeightEnum = {
  VeryLow: "very_low",
  Low: "low",
  Mid: "mid",
  Medium: "medium",
  High: "high",
  VeryHigh: "very_high",
} as const;
export type SignalInterestsEntitiesWeightEnum = ClosedEnum<
  typeof SignalInterestsEntitiesWeightEnum
>;

/**
 * Specifies the extent to which results should be influenced by the relevance of entities (in-domain or cross-domain). Higher values increase the influence of entities; lower values reduce their impact.
 */
export type SignalInterestsEntitiesWeight =
  | number
  | SignalInterestsEntitiesWeightEnum;

export type SignalInterestsTags = {
  tag?: string | undefined;
  weight?: number | undefined;
};

/**
 * Allows you to supply a list of tags to influence affinity scores. You can also include a `weight` property that will indicate the strength of influence for each tag in your list.
 *
 * @remarks
 *   - For GET requests: Provide a comma-separated list of tag IDs.
 *   - For POST requests, you can either:
 *     - Send the same string of comma-separated values.
 *     - Send an array of objects with "tag" and "weight" properties, such as:
 *       [
 *         { "tag": "urn:tag:genre:media:horror", "weight": 7 },
 *         { "tag": "urn:tag:genre:media:thriller", "weight": 20 }
 *       ]
 * Weights must be greater than 0 and are relative. So, a weight of 20 means that tag will more heavily influence affinity scores than a weight of 7.
 */
export type SignalInterestsTagsUnion =
  | Array<string>
  | Array<SignalInterestsTags>;

export const SignalInterestsTagsWeightEnum = {
  VeryLow: "very_low",
  Low: "low",
  Mid: "mid",
  Medium: "medium",
  High: "high",
  VeryHigh: "very_high",
} as const;
export type SignalInterestsTagsWeightEnum = ClosedEnum<
  typeof SignalInterestsTagsWeightEnum
>;

/**
 * Specifies the extent to which results should be influenced by the presence of tags (taste analysis). Higher values increase the influence of tags; lower values reduce their impact.
 */
export type SignalInterestsTagsWeight = number | SignalInterestsTagsWeightEnum;

export const SignalLocationWeightEnum = {
  VeryLow: "very_low",
  Low: "low",
  Mid: "mid",
  Medium: "medium",
  High: "high",
  VeryHigh: "very_high",
} as const;
export type SignalLocationWeightEnum = ClosedEnum<
  typeof SignalLocationWeightEnum
>;

/**
 * Specifies the extent to which results should be influenced by location-based signals (geospatial). Higher values increase the influence of location; lower values reduce its impact.
 */
export type SignalLocationWeight = number | SignalLocationWeightEnum;

/**
 * This parameter modifies the results sorting algorithm (affinity\|distance). The distance option can only be used when `filter.location`` is supplied.
 */
export const SortBy = {
  Affinity: "affinity",
  Distance: "distance",
} as const;
/**
 * This parameter modifies the results sorting algorithm (affinity\|distance). The distance option can only be used when `filter.location`` is supplied.
 */
export type SortBy = ClosedEnum<typeof SortBy>;

export type GetInsightsRequest = {
  /**
   * Filter by the category of entity to return (urn:entity:place).
   */
  filterType: FilterType;
  /**
   * The level of impact a trending entity has on the results. Supported by select categories only.
   */
  biasTrends?: BiasTrends | undefined;
  /**
   * Limits results to a set number of high-affinity entities per city. Set this to "properties.geocode.city" to enable city-based diversification. Cities are ranked based on the highest-affinity entity within them, and entities within each city are ordered by their individual affinities.
   *
   * @remarks
   */
  diversifyBy?: string | undefined;
  /**
   * Sets the maximum number of results to return per city when using "diversify.by": "properties.geocode.city". For example, if set to 5, the response will include up to 5 entities with the highest affinities in each city.
   *
   * @remarks
   */
  diversifyTake?: number | undefined;
  /**
   * When set to `true`, the response includes explainability metadata for each recommendation and for the overall result set.
   *
   * @remarks
   *
   * **Per-recommendation**: Each result includes a `query.explainability` section showing which input entities (e.g. `signal.interests.entities`) contributed to the recommendation and by how much. Scores are normalized between 0–1. Entities with scores ≥ 0.1 are always included; those below may be omitted to reduce response size.
   *
   * **Aggregate impact**: The top-level `query.explainability` object shows average influence of each input entity across top-N result subsets (e.g. top 3, 5, 10, all).
   *
   * **Note**: If explainability cannot be computed for the request, a warning is included under `query.explainability.warning`, but results still return normally.
   */
  featureExplainability?: boolean | undefined;
  /**
   * Filter by address using a partial string query.
   */
  filterAddress?: string | undefined;
  /**
   * Filter by a comma-separated list of content ratings based on the MPAA film rating system, which determines suitability for various audiences.
   */
  filterContentRating?: FilterContentRating | undefined;
  /**
   * Filter by the most recent date of birth desired for the queried person.
   */
  filterDateOfBirthMax?: RFCDate | undefined;
  /**
   * Filter by the earliest date of birth desired for the queried person.
   */
  filterDateOfBirthMin?: RFCDate | undefined;
  /**
   * Filter by the most recent date of death desired for the queried person.
   */
  filterDateOfDeathMax?: RFCDate | undefined;
  /**
   * Filter by the earliest date of death desired for the queried person.
   */
  filterDateOfDeathMin?: RFCDate | undefined;
  /**
   * Exclude entities associated with a comma-separated list of tags.
   */
  filterExcludeTags?: string | undefined;
  /**
   * Specifies how multiple `filter.exclude.tags` values are combined in the query. Use "union" (equivalent to a logical "or") to exclude results that contain at least one of the specified tags, or "intersection" (equivalent to a logical "and") to exclude only results that contain all specified tags. The default is "union".
   */
  operatorExcludeTags?: OperatorExcludeTags | undefined;
  /**
   * Filter results to include only entities that have one or more specified properties. Use `properties.image` to return only entities that include an image URL.
   *
   * @remarks
   */
  filterExists?: string | undefined;
  /**
   * Filter by a comma-separated list of external keys. (`resy`\|`michelin`\|`tablet`).
   */
  filterExternalExists?: string | undefined;
  /**
   * Specifies how multiple `filter.external.exists` values are combined in the query. Use "union" (equivalent to a logical "or") to return results that match at least one of the specified external keys (e.g., resy, michelin, or tablet), or "intersection" (equivalent to a logical "and") to return only results that match all specified external keys. The default is "union".
   */
  operatorFilterExternalExists?: OperatorFilterExternalExists | undefined;
  /**
   * Filter places to include only those with a Resy rating count less than or equal to the specified maximum.   Applies only to entities with `filter.type` of `urn:entity:place`.
   *
   * @remarks
   */
  filterExternalResyCountMax?: number | undefined;
  /**
   * Filter places to include only those with a Resy rating count greater than or equal to the specified minimum.   Applies only to entities with `filter.type` of `urn:entity:place`.
   *
   * @remarks
   */
  filterExternalResyCountMin?: number | undefined;
  /**
   * Filter by the maximum supported party size required for a Point of Interest.
   */
  filterExternalResyPartySizeMax?: number | undefined;
  /**
   * Filter by the minimum supported party size required for a Point of Interest.
   */
  filterExternalResyPartySizeMin?: number | undefined;
  /**
   * Filter places to include only those with a Resy rating less than or equal to the specified maximum (1–5 scale). Applies only to entities with `filter.type` of `urn:entity:place`.
   */
  filterExternalResyRatingMax?: number | undefined;
  /**
   * Filter places to include only those with a Resy rating greater than or equal to the specified minimum (1–5 scale). Applies only to entities with `filter.type` of `urn:entity:place`.
   */
  filterExternalResyRatingMin?: number | undefined;
  /**
   * Filter places to include only those with a Tripadvisor review count greater than or equal to the specified minimum. This filter only applies to entities with `filter.type` of `urn:entity:place`.
   *
   * @remarks
   */
  filterExternalTripadvisorRatingCountMin?: number | undefined;
  /**
   * Filter places to include only those with a Tripadvisor review count less than or equal to the specified maximum. This filter only applies to entities with `filter.type` of `urn:entity:place`.
   *
   * @remarks
   */
  filterExternalTripadvisorRatingCountMax?: number | undefined;
  /**
   * Filter places to include only those with a Tripadvisor rating less than or equal to the specified maximum. This filter only applies to entities with `filter.type` of `urn:entity:place`.
   *
   * @remarks
   */
  filterExternalTripadvisorRatingMax?: number | undefined;
  /**
   * Filter places to include only those with a Tripadvisor rating greater than or equal to the specified minimum. This filter only applies to entities with `filter.type` of `urn:entity:place`.
   *
   * @remarks
   */
  filterExternalTripadvisorRatingMin?: number | undefined;
  /**
   * Filter by the latest desired year for the final season of a TV show.
   */
  filterFinaleYearMax?: number | undefined;
  /**
   * Filter by the earliest desired year for the final season of a TV show.
   */
  filterFinaleYearMin?: number | undefined;
  /**
   * Filter results to align with a specific gender identity. Used to personalize output based on known or inferred gender preferences.
   *
   * @remarks
   */
  filterGender?: string | undefined;
  /**
   * Filter by `properties.geocode.admin1_region`. Exact match (usually state).
   */
  filterGeocodeAdmin1Region?: string | undefined;
  /**
   * Filter by `properties.geocode.admin2_region`. Exact match (often county or borough).
   */
  filterGeocodeAdmin2Region?: string | undefined;
  /**
   * Filter by `properties.geocode.country_code`. Exact match (two-letter country code).
   */
  filterGeocodeCountryCode?: string | undefined;
  /**
   * Filter by `properties.geocode.name`. Exact match (usually city or town name).
   */
  filterGeocodeName?: string | undefined;
  /**
   * Filter by the maximum desired hotel class (1-5, inclusive).
   */
  filterHotelClassMax?: number | undefined;
  /**
   * Filter by the minimum desired hotel class (1-5, inclusive).
   */
  filterHotelClassMin?: number | undefined;
  /**
   * Filter by the day of the week the Point of Interest must be open (Monday, Tuesday, etc.).
   */
  filterHours?: FilterHours | undefined;
  /**
   * Filter by a certain maximum year that shows were released or updated.
   */
  filterLatestKnownYearMax?: number | undefined;
  /**
   * Filter by a certain minimum year that shows were released or updated.
   */
  filterLatestKnownYearMin?: number | undefined;
  /**
   * Used to filter by a WKT `POINT`, `POLYGON`, `MULTIPOLYGON` or a single Qloo ID for a named `urn:entity:locality`. WKT is formatted as X then Y, therefore longitude is first (`POINT(-73.99823 40.722668)`). If a Qloo ID or WKT `POLYGON` is passed, `filter.location.radius` will create a fuzzy boundary when set to a value > 0.
   */
  filterLocation?: string | undefined;
  /**
   * Exclude results that fall within a specific location, defined by either a WKT `POINT`, `POLYGON`, `MULTIPOLYGON`, or a Qloo ID for a named `urn:entity:locality`.   WKT is formatted with longitude first (e.g., `POINT(-73.99823 40.722668)`).   When using a locality ID or a WKT `POLYGON`, setting `filter.location.radius` to a value > 0 creates a fuzzy exclusion boundary.
   *
   * @remarks
   */
  filterExcludeLocation?: string | undefined;
  /**
   * A query used to search for one or more named `urn:entity:locality` Qloo IDs for filtering requests, equivalent to passing the same Locality Qloo ID(s) into `filter.location`.
   *
   * @remarks
   *   - For **GET requests**: Provide a single locality query as a string.
   *   - For **POST requests**:
   *     - You can still send a single locality as a string.
   *     - Or you can send an array of locality names to query multiple localities at once. When multiple localities are provided, their geographic shapes are merged, and the system returns results with the highest affinities across the combined area.
   *
   * Locality queries are fuzzy-matched and case-insensitive. Examples include `New York City`, `Garden City`, `New York`, `Los Angeles`, `Lower East Side`, and AKAs like `The Big Apple`. When a single locality is supplied, the response JSON includes `query.locality.signal` with the matched Qloo entity. If multiple are supplied, this field is omitted. By default, the API includes a tuning that also captures nearby entities just outside the official boundaries of the locality. To turn this off and limit results strictly to within the locality, set `filter.location.radius=0`. If no localities are found, the API returns a 400 error.
   */
  filterLocationQuery?: string | Array<string> | undefined;
  /**
   * A query used to exclude results based on one or more named `urn:entity:locality` Qloo IDs, resolved from fuzzy-matched locality names.   This is equivalent to passing the resolved Locality Qloo ID(s) into `filter.exclude.location`.
   *
   * @remarks
   * - For **GET requests**: Provide a single locality query as a string. - For **POST requests**:
   *   - You can still send a single locality as a string.
   *   - Or send an array of locality names to exclude multiple areas at once. When multiple localities are provided, their geographic shapes are merged, and the system excludes results from across the combined area.
   *
   * Locality queries are case-insensitive and support common AKAs (e.g., `The Big Apple` for New York).   When a single locality is supplied, the response includes `query.locality.exclude.signal` with the matched Qloo entity.   If multiple are supplied, this field is omitted. If no localities are matched, the API returns a 400 error.
   */
  filterExcludeLocationQuery?: string | Array<string> | undefined;
  /**
   * Filter by a geohash. Geohashes are generated using the Python package pygeohash with a precision of 12 characters. This parameter returns all POIs that start with the specified geohash. For example, supplying `dr5rs` would allow returning the geohash `dr5rsjk4sr2w`.
   */
  filterLocationGeohash?: string | undefined;
  /**
   * Exclude all entities whose geohash starts with the specified prefix.   Geohashes are generated using the Python package `pygeohash` with a precision of 12 characters.   For example, supplying `dr5rs` would exclude any result whose geohash begins with `dr5rs`, such as `dr5rsjk4sr2w`.
   *
   * @remarks
   */
  filterExcludeLocationGeohash?: string | undefined;
  /**
   * Filter by the radius (in meters) when also supplying `filter.location` or `filter.location.query`.
   *
   * @remarks
   * When this parameter is **not provided**, the API applies a default tuning that slightly expands the locality boundary to include nearby entities outside its official shape.
   * To **disable** this behavior and strictly limit results to entities inside the defined locality boundary, set `filter.location.radius=0`.
   */
  filterLocationRadius?: number | undefined;
  /**
   * Filter by a comma-separated list of parental entity types (`urn:audience:communities`). Each type must match exactly.
   */
  filterParentsTypes?: Array<string> | undefined;
  /**
   * Filter by the maximum popularity percentile a Point of Interest must have (float, between 0 and 1; closer to 1 indicates higher popularity, e.g., 0.98 for the 98th percentile).
   */
  filterPopularityMax?: number | undefined;
  /**
   * Filter by the minimum popularity percentile required for a Point of Interest (float, between 0 and 1; closer to 1 indicates higher popularity, e.g., 0.98 for the 98th percentile).
   */
  filterPopularityMin?: number | undefined;
  /**
   * Filter by the maximum price level a Point of Interest can have (1|2|3|4, similar to dollar signs).
   */
  filterPriceLevelMax?: number | undefined;
  /**
   * Filter by the minimum price level a Point of Interest can have (1|2|3|4, similar to dollar signs).
   */
  filterPriceLevelMin?: number | undefined;
  /**
   * Filter places by a minimum price level, representing the lowest price in the desired range. Accepts an integer value between 0 and 1,000,000.
   */
  filterPriceRangeFrom?: number | undefined;
  /**
   * Filter places by a maximum price level, representing the highest price in the desired range. Accepts an integer value between 0 and 1,000,000. Only applies to places.
   */
  filterPriceRangeTo?: number | undefined;
  /**
   * maximum price
   */
  filterPriceMax?: number | undefined;
  /**
   * minimum price
   */
  filterPriceMin?: number | undefined;
  /**
   * Filter by the highest desired business rating.
   */
  filterPropertiesBusinessRatingMax?: number | undefined;
  /**
   * Filter by the lowest desired business rating.
   */
  filterPropertiesBusinessRatingMin?: number | undefined;
  /**
   * Filter by the latest desired year of initial publication for the work.
   */
  filterPublicationYearMax?: number | undefined;
  /**
   * Filter by the earliest desired year of initial publication for the work.
   */
  filterPublicationYearMin?: number | undefined;
  /**
   * Filter by the maximum Qloo rating a Point of Interest must have (float, between 0 and 5).
   */
  filterRatingMax?: number | undefined;
  /**
   * Filter by the minimum Qloo rating a Point of Interest must have (float, between 0 and 5).
   */
  filterRatingMin?: number | undefined;
  /**
   * Filter by a comma-separated list of brand entity IDs. Use this to narrow down place recommendations to specific brands. For example, to include only Walmart stores, pass the Walmart brand ID. Each ID must match exactly.
   */
  filterReferencesBrand?: Array<string> | undefined;
  /**
   * Filter by a list of countries where a movie or TV show was originally released.
   */
  filterReleaseCountry?: Array<string> | undefined;
  /**
   * Specifies how multiple `filter.release_country`` values are combined in the query. Use "union" (equivalent to a logical "or") to return results that match at least one of the specified countries, or "intersection" (equivalent to a logical "and") to return only results that match all specified countries. The default is "union".
   */
  operatorFilterReleaseCountry?: OperatorFilterReleaseCountry | undefined;
  /**
   * Filter by the latest desired release date.
   */
  filterReleaseDateMax?: RFCDate | undefined;
  /**
   * Filter by the earliest desired release date.
   */
  filterReleaseDateMin?: RFCDate | undefined;
  /**
   * Filter by the latest desired release year.
   */
  filterReleaseYearMax?: number | undefined;
  /**
   * Filter by the earliest desired release year.
   */
  filterReleaseYearMin?: number | undefined;
  /**
   * Filter by a comma-separated list of entity IDs. Often used to assess the affinity of an entity towards input.
   */
  filterResultsEntities?: string | undefined;
  /**
   * Search for one or more entities by name to use as filters.   - For **GET requests**: Provide a single entity name as a string. - For **POST requests**: You can provide a single name or an array of names.
   *
   * @remarks
   */
  filterResultsEntitiesQuery?: string | Array<string> | undefined;
  /**
   * A comma-separated list of entity IDs to remove from the results.
   */
  filterExcludeEntities?: string | undefined;
  /**
   * This parameter can only be supplied when using POST HTTP method, since it requires JSON encoded body. The value for `filter.exclude.entities.query` is a JSON array with objects containing the `name` and `address` properties. For a fuzzier search, just include an array of strings. When supplied, it overwrites the `filter.exclude.entities` object with resolved entity IDs. The response will contain a path `query.entities.exclude`, with partial Qloo entities that were matched by the query. If no entities are found, the API will throw a `400` error.
   */
  filterExcludeEntitiesQuery?:
    | Array<FilterExcludeEntitiesQuery | string>
    | undefined;
  /**
   * Filter by a comma-separated list of tag IDs. Often used to assess the affinity of a tag towards input.
   */
  filterResultsTags?: Array<string> | undefined;
  /**
   * Filter by a comma-separated list of tag IDs (urn:tag:genre:restaurant:Italian).
   */
  filterTags?: string | undefined;
  /**
   * Specifies how multiple `filter.tags` values are combined in the query. Use "union" (equivalent to a logical "or") to return results that match at least one of the specified tags, or "intersection" (equivalent to a logical "and") to return only results that match all specified tags. The default is "union".
   */
  operatorFilterTags?: OperatorFilterTags | undefined;
  /**
   * The number of results to skip, starting from 0. Allows arbitrary offsets but is less commonly used than `page`.
   */
  offset?: number | undefined;
  /**
   * Indicates the type of heatmap output desired: The default is geohashes. The other options are a city or a neighborhood.
   */
  outputHeatmapBoundary?: string | undefined;
  /**
   * The page number of results to return. This is equivalent to take + offset and is the recommended approach for most use cases.
   */
  page?: number | undefined;
  /**
   * A comma-separated list of age ranges that influence the affinity score.(35_and_younger\|36_to_55\|55_and_older).
   */
  signalDemographicsAge?: SignalDemographicsAge | undefined;
  /**
   * Specifies the extent to which results should be influenced by age-based demographic signals. Higher values increase the influence of age data; lower values reduce its impact.
   */
  signalDemographicsAgeWeight?:
    | number
    | SignalDemographicsAgeWeightEnum
    | undefined;
  /**
   * Specifies the extent to which results should be influenced by the preferences of the selected audience. Higher values increase the influence of audience preferences; lower values reduce their impact.
   */
  signalDemographicsAudiencesWeight?:
    | number
    | SignalDemographicsAudiencesWeightEnum
    | undefined;
  /**
   * A comma-separated list of audiences that influence the affinity score. Audience IDs can be retrieved via the v2/audiences search route.
   */
  signalDemographicsAudiences?: Array<string> | undefined;
  /**
   * Influence the affinity score based on gender (male\|female).
   */
  signalDemographicsGender?: SignalDemographicsGender | undefined;
  /**
   * Specifies the extent to which results should be influenced by gender-based demographic signals. Higher values increase the influence of gender data; lower values reduce its impact.
   */
  signalDemographicsGenderWeight?:
    | number
    | SignalDemographicsGenderWeightEnum
    | undefined;
  /**
   * Allows you to supply a list of entities to influence affinity scores. You can also include a `weight` property that will indicate the strength of influence for each entity in your list.
   *
   * @remarks
   *   - For GET requests: Provide a comma-separated list of entity IDs.
   *   - For POST requests, you can either:
   *     - Send the same string of comma-separated values.
   *     - Send an array of objects with "entity" and "weight" properties, such as:
   *       [
   *         { "entity": "urn:entity:movie:inception", "weight": 10 },
   *         { "entity": "urn:entity:movie:interstellar", "weight": 25 }
   *       ]
   * Weights must be greater than 0 and are relative. So, a weight of 25 means that entity will more heavily influence affinity scores than a weight of 10.
   */
  signalInterestsEntities?: Array<string> | undefined;
  /**
   * This parameter can only be supplied when using POST HTTP method, which requires a JSON-encoded body. The value should be a JSON array of objects with 'name' and 'address' properties; supports 'resolve_to' for specifying resolution to place, brand, or both.
   */
  signalInterestsEntitiesQuery?:
    | Array<SignalInterestsEntitiesQuery | string>
    | undefined;
  /**
   * Specifies the extent to which results should be influenced by the relevance of entities (in-domain or cross-domain). Higher values increase the influence of entities; lower values reduce their impact.
   */
  signalInterestsEntitiesWeight?:
    | number
    | SignalInterestsEntitiesWeightEnum
    | undefined;
  /**
   * Allows you to supply a list of tags to influence affinity scores. You can also include a `weight` property that will indicate the strength of influence for each tag in your list.
   *
   * @remarks
   *   - For GET requests: Provide a comma-separated list of tag IDs.
   *   - For POST requests, you can either:
   *     - Send the same string of comma-separated values.
   *     - Send an array of objects with "tag" and "weight" properties, such as:
   *       [
   *         { "tag": "urn:tag:genre:media:horror", "weight": 7 },
   *         { "tag": "urn:tag:genre:media:thriller", "weight": 20 }
   *       ]
   * Weights must be greater than 0 and are relative. So, a weight of 20 means that tag will more heavily influence affinity scores than a weight of 7.
   */
  signalInterestsTags?: Array<string> | Array<SignalInterestsTags> | undefined;
  /**
   * Specifies the extent to which results should be influenced by the presence of tags (taste analysis). Higher values increase the influence of tags; lower values reduce their impact.
   */
  signalInterestsTagsWeight?:
    | number
    | SignalInterestsTagsWeightEnum
    | undefined;
  /**
   * The geolocation to use for geospatial results. The value will be a WKT POINT, POLYGON or a single Qloo ID for a named urn:entity:locality to filter by. WKT is formatted as X then Y, therefore longitude is first (POINT(-73.99823 40.722668)). Unlike filter.location.radius, signal.location.radius is ignored if a Qloo ID or WKT POLYGON is passed.
   */
  signalLocation?: string | undefined;
  /**
   * The optional radius (in meters), used when providing a WKT POINT. We generally recommend avoiding this parameter, as it overrides dynamic density discovery.
   */
  signalLocationRadius?: number | undefined;
  /**
   * A string query used to search for a named urn:entity:locality Qloo ID for geospatial results, effectively equivalent to passing the same Locality Qloo ID into signal.location. Examples of locality queries include New York City, Garden City, New York, Los Angeles, Lower East Side, and AKAs like The Big Apple. These queries are fuzzy-matched and case-insensitive. When filter.location.query is supplied, the response JSON will include query.locality.signal, which contains the partially matched Qloo entity. If no locality is found, the API will return a 400 error.
   */
  signalLocationQuery?: string | undefined;
  /**
   * Specifies the extent to which results should be influenced by location-based signals (geospatial). Higher values increase the influence of location; lower values reduce its impact.
   */
  signalLocationWeight?: number | SignalLocationWeightEnum | undefined;
  /**
   * This parameter modifies the results sorting algorithm (affinity\|distance). The distance option can only be used when `filter.location`` is supplied.
   */
  sortBy?: SortBy | undefined;
  /**
   * The number of results to return.
   */
  take?: number | undefined;
};

export type GetInsightsResults = {
  entities?: Array<any> | undefined;
  duration?: number | undefined;
};

/**
 * Successful Operation
 */
export type GetInsightsResponse = {
  success?: boolean | undefined;
  results?: GetInsightsResults | undefined;
};

/** @internal */
export const FilterType$inboundSchema: z.ZodNativeEnum<typeof FilterType> = z
  .nativeEnum(FilterType);

/** @internal */
export const FilterType$outboundSchema: z.ZodNativeEnum<typeof FilterType> =
  FilterType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FilterType$ {
  /** @deprecated use `FilterType$inboundSchema` instead. */
  export const inboundSchema = FilterType$inboundSchema;
  /** @deprecated use `FilterType$outboundSchema` instead. */
  export const outboundSchema = FilterType$outboundSchema;
}

/** @internal */
export const BiasTrends$inboundSchema: z.ZodNativeEnum<typeof BiasTrends> = z
  .nativeEnum(BiasTrends);

/** @internal */
export const BiasTrends$outboundSchema: z.ZodNativeEnum<typeof BiasTrends> =
  BiasTrends$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BiasTrends$ {
  /** @deprecated use `BiasTrends$inboundSchema` instead. */
  export const inboundSchema = BiasTrends$inboundSchema;
  /** @deprecated use `BiasTrends$outboundSchema` instead. */
  export const outboundSchema = BiasTrends$outboundSchema;
}

/** @internal */
export const FilterContentRating$inboundSchema: z.ZodNativeEnum<
  typeof FilterContentRating
> = z.nativeEnum(FilterContentRating);

/** @internal */
export const FilterContentRating$outboundSchema: z.ZodNativeEnum<
  typeof FilterContentRating
> = FilterContentRating$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FilterContentRating$ {
  /** @deprecated use `FilterContentRating$inboundSchema` instead. */
  export const inboundSchema = FilterContentRating$inboundSchema;
  /** @deprecated use `FilterContentRating$outboundSchema` instead. */
  export const outboundSchema = FilterContentRating$outboundSchema;
}

/** @internal */
export const OperatorExcludeTags$inboundSchema: z.ZodNativeEnum<
  typeof OperatorExcludeTags
> = z.nativeEnum(OperatorExcludeTags);

/** @internal */
export const OperatorExcludeTags$outboundSchema: z.ZodNativeEnum<
  typeof OperatorExcludeTags
> = OperatorExcludeTags$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OperatorExcludeTags$ {
  /** @deprecated use `OperatorExcludeTags$inboundSchema` instead. */
  export const inboundSchema = OperatorExcludeTags$inboundSchema;
  /** @deprecated use `OperatorExcludeTags$outboundSchema` instead. */
  export const outboundSchema = OperatorExcludeTags$outboundSchema;
}

/** @internal */
export const OperatorFilterExternalExists$inboundSchema: z.ZodNativeEnum<
  typeof OperatorFilterExternalExists
> = z.nativeEnum(OperatorFilterExternalExists);

/** @internal */
export const OperatorFilterExternalExists$outboundSchema: z.ZodNativeEnum<
  typeof OperatorFilterExternalExists
> = OperatorFilterExternalExists$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OperatorFilterExternalExists$ {
  /** @deprecated use `OperatorFilterExternalExists$inboundSchema` instead. */
  export const inboundSchema = OperatorFilterExternalExists$inboundSchema;
  /** @deprecated use `OperatorFilterExternalExists$outboundSchema` instead. */
  export const outboundSchema = OperatorFilterExternalExists$outboundSchema;
}

/** @internal */
export const FilterHours$inboundSchema: z.ZodNativeEnum<typeof FilterHours> = z
  .nativeEnum(FilterHours);

/** @internal */
export const FilterHours$outboundSchema: z.ZodNativeEnum<typeof FilterHours> =
  FilterHours$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FilterHours$ {
  /** @deprecated use `FilterHours$inboundSchema` instead. */
  export const inboundSchema = FilterHours$inboundSchema;
  /** @deprecated use `FilterHours$outboundSchema` instead. */
  export const outboundSchema = FilterHours$outboundSchema;
}

/** @internal */
export const FilterLocationQuery$inboundSchema: z.ZodType<
  FilterLocationQuery,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);

/** @internal */
export type FilterLocationQuery$Outbound = string | Array<string>;

/** @internal */
export const FilterLocationQuery$outboundSchema: z.ZodType<
  FilterLocationQuery$Outbound,
  z.ZodTypeDef,
  FilterLocationQuery
> = z.union([z.string(), z.array(z.string())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FilterLocationQuery$ {
  /** @deprecated use `FilterLocationQuery$inboundSchema` instead. */
  export const inboundSchema = FilterLocationQuery$inboundSchema;
  /** @deprecated use `FilterLocationQuery$outboundSchema` instead. */
  export const outboundSchema = FilterLocationQuery$outboundSchema;
  /** @deprecated use `FilterLocationQuery$Outbound` instead. */
  export type Outbound = FilterLocationQuery$Outbound;
}

export function filterLocationQueryToJSON(
  filterLocationQuery: FilterLocationQuery,
): string {
  return JSON.stringify(
    FilterLocationQuery$outboundSchema.parse(filterLocationQuery),
  );
}

export function filterLocationQueryFromJSON(
  jsonString: string,
): SafeParseResult<FilterLocationQuery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FilterLocationQuery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FilterLocationQuery' from JSON`,
  );
}

/** @internal */
export const FilterExcludeLocationQuery$inboundSchema: z.ZodType<
  FilterExcludeLocationQuery,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);

/** @internal */
export type FilterExcludeLocationQuery$Outbound = string | Array<string>;

/** @internal */
export const FilterExcludeLocationQuery$outboundSchema: z.ZodType<
  FilterExcludeLocationQuery$Outbound,
  z.ZodTypeDef,
  FilterExcludeLocationQuery
> = z.union([z.string(), z.array(z.string())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FilterExcludeLocationQuery$ {
  /** @deprecated use `FilterExcludeLocationQuery$inboundSchema` instead. */
  export const inboundSchema = FilterExcludeLocationQuery$inboundSchema;
  /** @deprecated use `FilterExcludeLocationQuery$outboundSchema` instead. */
  export const outboundSchema = FilterExcludeLocationQuery$outboundSchema;
  /** @deprecated use `FilterExcludeLocationQuery$Outbound` instead. */
  export type Outbound = FilterExcludeLocationQuery$Outbound;
}

export function filterExcludeLocationQueryToJSON(
  filterExcludeLocationQuery: FilterExcludeLocationQuery,
): string {
  return JSON.stringify(
    FilterExcludeLocationQuery$outboundSchema.parse(filterExcludeLocationQuery),
  );
}

export function filterExcludeLocationQueryFromJSON(
  jsonString: string,
): SafeParseResult<FilterExcludeLocationQuery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FilterExcludeLocationQuery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FilterExcludeLocationQuery' from JSON`,
  );
}

/** @internal */
export const OperatorFilterReleaseCountry$inboundSchema: z.ZodNativeEnum<
  typeof OperatorFilterReleaseCountry
> = z.nativeEnum(OperatorFilterReleaseCountry);

/** @internal */
export const OperatorFilterReleaseCountry$outboundSchema: z.ZodNativeEnum<
  typeof OperatorFilterReleaseCountry
> = OperatorFilterReleaseCountry$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OperatorFilterReleaseCountry$ {
  /** @deprecated use `OperatorFilterReleaseCountry$inboundSchema` instead. */
  export const inboundSchema = OperatorFilterReleaseCountry$inboundSchema;
  /** @deprecated use `OperatorFilterReleaseCountry$outboundSchema` instead. */
  export const outboundSchema = OperatorFilterReleaseCountry$outboundSchema;
}

/** @internal */
export const FilterResultsEntitiesQuery$inboundSchema: z.ZodType<
  FilterResultsEntitiesQuery,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);

/** @internal */
export type FilterResultsEntitiesQuery$Outbound = string | Array<string>;

/** @internal */
export const FilterResultsEntitiesQuery$outboundSchema: z.ZodType<
  FilterResultsEntitiesQuery$Outbound,
  z.ZodTypeDef,
  FilterResultsEntitiesQuery
> = z.union([z.string(), z.array(z.string())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FilterResultsEntitiesQuery$ {
  /** @deprecated use `FilterResultsEntitiesQuery$inboundSchema` instead. */
  export const inboundSchema = FilterResultsEntitiesQuery$inboundSchema;
  /** @deprecated use `FilterResultsEntitiesQuery$outboundSchema` instead. */
  export const outboundSchema = FilterResultsEntitiesQuery$outboundSchema;
  /** @deprecated use `FilterResultsEntitiesQuery$Outbound` instead. */
  export type Outbound = FilterResultsEntitiesQuery$Outbound;
}

export function filterResultsEntitiesQueryToJSON(
  filterResultsEntitiesQuery: FilterResultsEntitiesQuery,
): string {
  return JSON.stringify(
    FilterResultsEntitiesQuery$outboundSchema.parse(filterResultsEntitiesQuery),
  );
}

export function filterResultsEntitiesQueryFromJSON(
  jsonString: string,
): SafeParseResult<FilterResultsEntitiesQuery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FilterResultsEntitiesQuery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FilterResultsEntitiesQuery' from JSON`,
  );
}

/** @internal */
export const FilterExcludeEntitiesQuery$inboundSchema: z.ZodType<
  FilterExcludeEntitiesQuery,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  address: z.string().optional(),
});

/** @internal */
export type FilterExcludeEntitiesQuery$Outbound = {
  name?: string | undefined;
  address?: string | undefined;
};

/** @internal */
export const FilterExcludeEntitiesQuery$outboundSchema: z.ZodType<
  FilterExcludeEntitiesQuery$Outbound,
  z.ZodTypeDef,
  FilterExcludeEntitiesQuery
> = z.object({
  name: z.string().optional(),
  address: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FilterExcludeEntitiesQuery$ {
  /** @deprecated use `FilterExcludeEntitiesQuery$inboundSchema` instead. */
  export const inboundSchema = FilterExcludeEntitiesQuery$inboundSchema;
  /** @deprecated use `FilterExcludeEntitiesQuery$outboundSchema` instead. */
  export const outboundSchema = FilterExcludeEntitiesQuery$outboundSchema;
  /** @deprecated use `FilterExcludeEntitiesQuery$Outbound` instead. */
  export type Outbound = FilterExcludeEntitiesQuery$Outbound;
}

export function filterExcludeEntitiesQueryToJSON(
  filterExcludeEntitiesQuery: FilterExcludeEntitiesQuery,
): string {
  return JSON.stringify(
    FilterExcludeEntitiesQuery$outboundSchema.parse(filterExcludeEntitiesQuery),
  );
}

export function filterExcludeEntitiesQueryFromJSON(
  jsonString: string,
): SafeParseResult<FilterExcludeEntitiesQuery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FilterExcludeEntitiesQuery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FilterExcludeEntitiesQuery' from JSON`,
  );
}

/** @internal */
export const FilterExcludeEntitiesQueryUnion$inboundSchema: z.ZodType<
  FilterExcludeEntitiesQueryUnion,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => FilterExcludeEntitiesQuery$inboundSchema),
  z.string(),
]);

/** @internal */
export type FilterExcludeEntitiesQueryUnion$Outbound =
  | FilterExcludeEntitiesQuery$Outbound
  | string;

/** @internal */
export const FilterExcludeEntitiesQueryUnion$outboundSchema: z.ZodType<
  FilterExcludeEntitiesQueryUnion$Outbound,
  z.ZodTypeDef,
  FilterExcludeEntitiesQueryUnion
> = z.union([
  z.lazy(() => FilterExcludeEntitiesQuery$outboundSchema),
  z.string(),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FilterExcludeEntitiesQueryUnion$ {
  /** @deprecated use `FilterExcludeEntitiesQueryUnion$inboundSchema` instead. */
  export const inboundSchema = FilterExcludeEntitiesQueryUnion$inboundSchema;
  /** @deprecated use `FilterExcludeEntitiesQueryUnion$outboundSchema` instead. */
  export const outboundSchema = FilterExcludeEntitiesQueryUnion$outboundSchema;
  /** @deprecated use `FilterExcludeEntitiesQueryUnion$Outbound` instead. */
  export type Outbound = FilterExcludeEntitiesQueryUnion$Outbound;
}

export function filterExcludeEntitiesQueryUnionToJSON(
  filterExcludeEntitiesQueryUnion: FilterExcludeEntitiesQueryUnion,
): string {
  return JSON.stringify(
    FilterExcludeEntitiesQueryUnion$outboundSchema.parse(
      filterExcludeEntitiesQueryUnion,
    ),
  );
}

export function filterExcludeEntitiesQueryUnionFromJSON(
  jsonString: string,
): SafeParseResult<FilterExcludeEntitiesQueryUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FilterExcludeEntitiesQueryUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FilterExcludeEntitiesQueryUnion' from JSON`,
  );
}

/** @internal */
export const OperatorFilterTags$inboundSchema: z.ZodNativeEnum<
  typeof OperatorFilterTags
> = z.nativeEnum(OperatorFilterTags);

/** @internal */
export const OperatorFilterTags$outboundSchema: z.ZodNativeEnum<
  typeof OperatorFilterTags
> = OperatorFilterTags$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OperatorFilterTags$ {
  /** @deprecated use `OperatorFilterTags$inboundSchema` instead. */
  export const inboundSchema = OperatorFilterTags$inboundSchema;
  /** @deprecated use `OperatorFilterTags$outboundSchema` instead. */
  export const outboundSchema = OperatorFilterTags$outboundSchema;
}

/** @internal */
export const SignalDemographicsAge$inboundSchema: z.ZodNativeEnum<
  typeof SignalDemographicsAge
> = z.nativeEnum(SignalDemographicsAge);

/** @internal */
export const SignalDemographicsAge$outboundSchema: z.ZodNativeEnum<
  typeof SignalDemographicsAge
> = SignalDemographicsAge$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SignalDemographicsAge$ {
  /** @deprecated use `SignalDemographicsAge$inboundSchema` instead. */
  export const inboundSchema = SignalDemographicsAge$inboundSchema;
  /** @deprecated use `SignalDemographicsAge$outboundSchema` instead. */
  export const outboundSchema = SignalDemographicsAge$outboundSchema;
}

/** @internal */
export const SignalDemographicsAgeWeightEnum$inboundSchema: z.ZodNativeEnum<
  typeof SignalDemographicsAgeWeightEnum
> = z.nativeEnum(SignalDemographicsAgeWeightEnum);

/** @internal */
export const SignalDemographicsAgeWeightEnum$outboundSchema: z.ZodNativeEnum<
  typeof SignalDemographicsAgeWeightEnum
> = SignalDemographicsAgeWeightEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SignalDemographicsAgeWeightEnum$ {
  /** @deprecated use `SignalDemographicsAgeWeightEnum$inboundSchema` instead. */
  export const inboundSchema = SignalDemographicsAgeWeightEnum$inboundSchema;
  /** @deprecated use `SignalDemographicsAgeWeightEnum$outboundSchema` instead. */
  export const outboundSchema = SignalDemographicsAgeWeightEnum$outboundSchema;
}

/** @internal */
export const SignalDemographicsAgeWeight$inboundSchema: z.ZodType<
  SignalDemographicsAgeWeight,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), SignalDemographicsAgeWeightEnum$inboundSchema]);

/** @internal */
export type SignalDemographicsAgeWeight$Outbound = number | string;

/** @internal */
export const SignalDemographicsAgeWeight$outboundSchema: z.ZodType<
  SignalDemographicsAgeWeight$Outbound,
  z.ZodTypeDef,
  SignalDemographicsAgeWeight
> = z.union([z.number(), SignalDemographicsAgeWeightEnum$outboundSchema]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SignalDemographicsAgeWeight$ {
  /** @deprecated use `SignalDemographicsAgeWeight$inboundSchema` instead. */
  export const inboundSchema = SignalDemographicsAgeWeight$inboundSchema;
  /** @deprecated use `SignalDemographicsAgeWeight$outboundSchema` instead. */
  export const outboundSchema = SignalDemographicsAgeWeight$outboundSchema;
  /** @deprecated use `SignalDemographicsAgeWeight$Outbound` instead. */
  export type Outbound = SignalDemographicsAgeWeight$Outbound;
}

export function signalDemographicsAgeWeightToJSON(
  signalDemographicsAgeWeight: SignalDemographicsAgeWeight,
): string {
  return JSON.stringify(
    SignalDemographicsAgeWeight$outboundSchema.parse(
      signalDemographicsAgeWeight,
    ),
  );
}

export function signalDemographicsAgeWeightFromJSON(
  jsonString: string,
): SafeParseResult<SignalDemographicsAgeWeight, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SignalDemographicsAgeWeight$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SignalDemographicsAgeWeight' from JSON`,
  );
}

/** @internal */
export const SignalDemographicsAudiencesWeightEnum$inboundSchema:
  z.ZodNativeEnum<typeof SignalDemographicsAudiencesWeightEnum> = z.nativeEnum(
    SignalDemographicsAudiencesWeightEnum,
  );

/** @internal */
export const SignalDemographicsAudiencesWeightEnum$outboundSchema:
  z.ZodNativeEnum<typeof SignalDemographicsAudiencesWeightEnum> =
    SignalDemographicsAudiencesWeightEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SignalDemographicsAudiencesWeightEnum$ {
  /** @deprecated use `SignalDemographicsAudiencesWeightEnum$inboundSchema` instead. */
  export const inboundSchema =
    SignalDemographicsAudiencesWeightEnum$inboundSchema;
  /** @deprecated use `SignalDemographicsAudiencesWeightEnum$outboundSchema` instead. */
  export const outboundSchema =
    SignalDemographicsAudiencesWeightEnum$outboundSchema;
}

/** @internal */
export const SignalDemographicsAudiencesWeight$inboundSchema: z.ZodType<
  SignalDemographicsAudiencesWeight,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), SignalDemographicsAudiencesWeightEnum$inboundSchema]);

/** @internal */
export type SignalDemographicsAudiencesWeight$Outbound = number | string;

/** @internal */
export const SignalDemographicsAudiencesWeight$outboundSchema: z.ZodType<
  SignalDemographicsAudiencesWeight$Outbound,
  z.ZodTypeDef,
  SignalDemographicsAudiencesWeight
> = z.union([z.number(), SignalDemographicsAudiencesWeightEnum$outboundSchema]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SignalDemographicsAudiencesWeight$ {
  /** @deprecated use `SignalDemographicsAudiencesWeight$inboundSchema` instead. */
  export const inboundSchema = SignalDemographicsAudiencesWeight$inboundSchema;
  /** @deprecated use `SignalDemographicsAudiencesWeight$outboundSchema` instead. */
  export const outboundSchema =
    SignalDemographicsAudiencesWeight$outboundSchema;
  /** @deprecated use `SignalDemographicsAudiencesWeight$Outbound` instead. */
  export type Outbound = SignalDemographicsAudiencesWeight$Outbound;
}

export function signalDemographicsAudiencesWeightToJSON(
  signalDemographicsAudiencesWeight: SignalDemographicsAudiencesWeight,
): string {
  return JSON.stringify(
    SignalDemographicsAudiencesWeight$outboundSchema.parse(
      signalDemographicsAudiencesWeight,
    ),
  );
}

export function signalDemographicsAudiencesWeightFromJSON(
  jsonString: string,
): SafeParseResult<SignalDemographicsAudiencesWeight, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SignalDemographicsAudiencesWeight$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SignalDemographicsAudiencesWeight' from JSON`,
  );
}

/** @internal */
export const SignalDemographicsGender$inboundSchema: z.ZodNativeEnum<
  typeof SignalDemographicsGender
> = z.nativeEnum(SignalDemographicsGender);

/** @internal */
export const SignalDemographicsGender$outboundSchema: z.ZodNativeEnum<
  typeof SignalDemographicsGender
> = SignalDemographicsGender$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SignalDemographicsGender$ {
  /** @deprecated use `SignalDemographicsGender$inboundSchema` instead. */
  export const inboundSchema = SignalDemographicsGender$inboundSchema;
  /** @deprecated use `SignalDemographicsGender$outboundSchema` instead. */
  export const outboundSchema = SignalDemographicsGender$outboundSchema;
}

/** @internal */
export const SignalDemographicsGenderWeightEnum$inboundSchema: z.ZodNativeEnum<
  typeof SignalDemographicsGenderWeightEnum
> = z.nativeEnum(SignalDemographicsGenderWeightEnum);

/** @internal */
export const SignalDemographicsGenderWeightEnum$outboundSchema: z.ZodNativeEnum<
  typeof SignalDemographicsGenderWeightEnum
> = SignalDemographicsGenderWeightEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SignalDemographicsGenderWeightEnum$ {
  /** @deprecated use `SignalDemographicsGenderWeightEnum$inboundSchema` instead. */
  export const inboundSchema = SignalDemographicsGenderWeightEnum$inboundSchema;
  /** @deprecated use `SignalDemographicsGenderWeightEnum$outboundSchema` instead. */
  export const outboundSchema =
    SignalDemographicsGenderWeightEnum$outboundSchema;
}

/** @internal */
export const SignalDemographicsGenderWeight$inboundSchema: z.ZodType<
  SignalDemographicsGenderWeight,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), SignalDemographicsGenderWeightEnum$inboundSchema]);

/** @internal */
export type SignalDemographicsGenderWeight$Outbound = number | string;

/** @internal */
export const SignalDemographicsGenderWeight$outboundSchema: z.ZodType<
  SignalDemographicsGenderWeight$Outbound,
  z.ZodTypeDef,
  SignalDemographicsGenderWeight
> = z.union([z.number(), SignalDemographicsGenderWeightEnum$outboundSchema]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SignalDemographicsGenderWeight$ {
  /** @deprecated use `SignalDemographicsGenderWeight$inboundSchema` instead. */
  export const inboundSchema = SignalDemographicsGenderWeight$inboundSchema;
  /** @deprecated use `SignalDemographicsGenderWeight$outboundSchema` instead. */
  export const outboundSchema = SignalDemographicsGenderWeight$outboundSchema;
  /** @deprecated use `SignalDemographicsGenderWeight$Outbound` instead. */
  export type Outbound = SignalDemographicsGenderWeight$Outbound;
}

export function signalDemographicsGenderWeightToJSON(
  signalDemographicsGenderWeight: SignalDemographicsGenderWeight,
): string {
  return JSON.stringify(
    SignalDemographicsGenderWeight$outboundSchema.parse(
      signalDemographicsGenderWeight,
    ),
  );
}

export function signalDemographicsGenderWeightFromJSON(
  jsonString: string,
): SafeParseResult<SignalDemographicsGenderWeight, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SignalDemographicsGenderWeight$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SignalDemographicsGenderWeight' from JSON`,
  );
}

/** @internal */
export const SignalInterestsEntitiesQuery$inboundSchema: z.ZodType<
  SignalInterestsEntitiesQuery,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  address: z.string().optional(),
});

/** @internal */
export type SignalInterestsEntitiesQuery$Outbound = {
  name?: string | undefined;
  address?: string | undefined;
};

/** @internal */
export const SignalInterestsEntitiesQuery$outboundSchema: z.ZodType<
  SignalInterestsEntitiesQuery$Outbound,
  z.ZodTypeDef,
  SignalInterestsEntitiesQuery
> = z.object({
  name: z.string().optional(),
  address: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SignalInterestsEntitiesQuery$ {
  /** @deprecated use `SignalInterestsEntitiesQuery$inboundSchema` instead. */
  export const inboundSchema = SignalInterestsEntitiesQuery$inboundSchema;
  /** @deprecated use `SignalInterestsEntitiesQuery$outboundSchema` instead. */
  export const outboundSchema = SignalInterestsEntitiesQuery$outboundSchema;
  /** @deprecated use `SignalInterestsEntitiesQuery$Outbound` instead. */
  export type Outbound = SignalInterestsEntitiesQuery$Outbound;
}

export function signalInterestsEntitiesQueryToJSON(
  signalInterestsEntitiesQuery: SignalInterestsEntitiesQuery,
): string {
  return JSON.stringify(
    SignalInterestsEntitiesQuery$outboundSchema.parse(
      signalInterestsEntitiesQuery,
    ),
  );
}

export function signalInterestsEntitiesQueryFromJSON(
  jsonString: string,
): SafeParseResult<SignalInterestsEntitiesQuery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SignalInterestsEntitiesQuery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SignalInterestsEntitiesQuery' from JSON`,
  );
}

/** @internal */
export const SignalInterestsEntitiesQueryUnion$inboundSchema: z.ZodType<
  SignalInterestsEntitiesQueryUnion,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => SignalInterestsEntitiesQuery$inboundSchema),
  z.string(),
]);

/** @internal */
export type SignalInterestsEntitiesQueryUnion$Outbound =
  | SignalInterestsEntitiesQuery$Outbound
  | string;

/** @internal */
export const SignalInterestsEntitiesQueryUnion$outboundSchema: z.ZodType<
  SignalInterestsEntitiesQueryUnion$Outbound,
  z.ZodTypeDef,
  SignalInterestsEntitiesQueryUnion
> = z.union([
  z.lazy(() => SignalInterestsEntitiesQuery$outboundSchema),
  z.string(),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SignalInterestsEntitiesQueryUnion$ {
  /** @deprecated use `SignalInterestsEntitiesQueryUnion$inboundSchema` instead. */
  export const inboundSchema = SignalInterestsEntitiesQueryUnion$inboundSchema;
  /** @deprecated use `SignalInterestsEntitiesQueryUnion$outboundSchema` instead. */
  export const outboundSchema =
    SignalInterestsEntitiesQueryUnion$outboundSchema;
  /** @deprecated use `SignalInterestsEntitiesQueryUnion$Outbound` instead. */
  export type Outbound = SignalInterestsEntitiesQueryUnion$Outbound;
}

export function signalInterestsEntitiesQueryUnionToJSON(
  signalInterestsEntitiesQueryUnion: SignalInterestsEntitiesQueryUnion,
): string {
  return JSON.stringify(
    SignalInterestsEntitiesQueryUnion$outboundSchema.parse(
      signalInterestsEntitiesQueryUnion,
    ),
  );
}

export function signalInterestsEntitiesQueryUnionFromJSON(
  jsonString: string,
): SafeParseResult<SignalInterestsEntitiesQueryUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SignalInterestsEntitiesQueryUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SignalInterestsEntitiesQueryUnion' from JSON`,
  );
}

/** @internal */
export const SignalInterestsEntitiesWeightEnum$inboundSchema: z.ZodNativeEnum<
  typeof SignalInterestsEntitiesWeightEnum
> = z.nativeEnum(SignalInterestsEntitiesWeightEnum);

/** @internal */
export const SignalInterestsEntitiesWeightEnum$outboundSchema: z.ZodNativeEnum<
  typeof SignalInterestsEntitiesWeightEnum
> = SignalInterestsEntitiesWeightEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SignalInterestsEntitiesWeightEnum$ {
  /** @deprecated use `SignalInterestsEntitiesWeightEnum$inboundSchema` instead. */
  export const inboundSchema = SignalInterestsEntitiesWeightEnum$inboundSchema;
  /** @deprecated use `SignalInterestsEntitiesWeightEnum$outboundSchema` instead. */
  export const outboundSchema =
    SignalInterestsEntitiesWeightEnum$outboundSchema;
}

/** @internal */
export const SignalInterestsEntitiesWeight$inboundSchema: z.ZodType<
  SignalInterestsEntitiesWeight,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), SignalInterestsEntitiesWeightEnum$inboundSchema]);

/** @internal */
export type SignalInterestsEntitiesWeight$Outbound = number | string;

/** @internal */
export const SignalInterestsEntitiesWeight$outboundSchema: z.ZodType<
  SignalInterestsEntitiesWeight$Outbound,
  z.ZodTypeDef,
  SignalInterestsEntitiesWeight
> = z.union([z.number(), SignalInterestsEntitiesWeightEnum$outboundSchema]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SignalInterestsEntitiesWeight$ {
  /** @deprecated use `SignalInterestsEntitiesWeight$inboundSchema` instead. */
  export const inboundSchema = SignalInterestsEntitiesWeight$inboundSchema;
  /** @deprecated use `SignalInterestsEntitiesWeight$outboundSchema` instead. */
  export const outboundSchema = SignalInterestsEntitiesWeight$outboundSchema;
  /** @deprecated use `SignalInterestsEntitiesWeight$Outbound` instead. */
  export type Outbound = SignalInterestsEntitiesWeight$Outbound;
}

export function signalInterestsEntitiesWeightToJSON(
  signalInterestsEntitiesWeight: SignalInterestsEntitiesWeight,
): string {
  return JSON.stringify(
    SignalInterestsEntitiesWeight$outboundSchema.parse(
      signalInterestsEntitiesWeight,
    ),
  );
}

export function signalInterestsEntitiesWeightFromJSON(
  jsonString: string,
): SafeParseResult<SignalInterestsEntitiesWeight, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SignalInterestsEntitiesWeight$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SignalInterestsEntitiesWeight' from JSON`,
  );
}

/** @internal */
export const SignalInterestsTags$inboundSchema: z.ZodType<
  SignalInterestsTags,
  z.ZodTypeDef,
  unknown
> = z.object({
  tag: z.string().optional(),
  weight: z.number().int().optional(),
});

/** @internal */
export type SignalInterestsTags$Outbound = {
  tag?: string | undefined;
  weight?: number | undefined;
};

/** @internal */
export const SignalInterestsTags$outboundSchema: z.ZodType<
  SignalInterestsTags$Outbound,
  z.ZodTypeDef,
  SignalInterestsTags
> = z.object({
  tag: z.string().optional(),
  weight: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SignalInterestsTags$ {
  /** @deprecated use `SignalInterestsTags$inboundSchema` instead. */
  export const inboundSchema = SignalInterestsTags$inboundSchema;
  /** @deprecated use `SignalInterestsTags$outboundSchema` instead. */
  export const outboundSchema = SignalInterestsTags$outboundSchema;
  /** @deprecated use `SignalInterestsTags$Outbound` instead. */
  export type Outbound = SignalInterestsTags$Outbound;
}

export function signalInterestsTagsToJSON(
  signalInterestsTags: SignalInterestsTags,
): string {
  return JSON.stringify(
    SignalInterestsTags$outboundSchema.parse(signalInterestsTags),
  );
}

export function signalInterestsTagsFromJSON(
  jsonString: string,
): SafeParseResult<SignalInterestsTags, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SignalInterestsTags$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SignalInterestsTags' from JSON`,
  );
}

/** @internal */
export const SignalInterestsTagsUnion$inboundSchema: z.ZodType<
  SignalInterestsTagsUnion,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.array(z.string()),
  z.array(z.lazy(() => SignalInterestsTags$inboundSchema)),
]);

/** @internal */
export type SignalInterestsTagsUnion$Outbound =
  | Array<string>
  | Array<SignalInterestsTags$Outbound>;

/** @internal */
export const SignalInterestsTagsUnion$outboundSchema: z.ZodType<
  SignalInterestsTagsUnion$Outbound,
  z.ZodTypeDef,
  SignalInterestsTagsUnion
> = z.union([
  z.array(z.string()),
  z.array(z.lazy(() => SignalInterestsTags$outboundSchema)),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SignalInterestsTagsUnion$ {
  /** @deprecated use `SignalInterestsTagsUnion$inboundSchema` instead. */
  export const inboundSchema = SignalInterestsTagsUnion$inboundSchema;
  /** @deprecated use `SignalInterestsTagsUnion$outboundSchema` instead. */
  export const outboundSchema = SignalInterestsTagsUnion$outboundSchema;
  /** @deprecated use `SignalInterestsTagsUnion$Outbound` instead. */
  export type Outbound = SignalInterestsTagsUnion$Outbound;
}

export function signalInterestsTagsUnionToJSON(
  signalInterestsTagsUnion: SignalInterestsTagsUnion,
): string {
  return JSON.stringify(
    SignalInterestsTagsUnion$outboundSchema.parse(signalInterestsTagsUnion),
  );
}

export function signalInterestsTagsUnionFromJSON(
  jsonString: string,
): SafeParseResult<SignalInterestsTagsUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SignalInterestsTagsUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SignalInterestsTagsUnion' from JSON`,
  );
}

/** @internal */
export const SignalInterestsTagsWeightEnum$inboundSchema: z.ZodNativeEnum<
  typeof SignalInterestsTagsWeightEnum
> = z.nativeEnum(SignalInterestsTagsWeightEnum);

/** @internal */
export const SignalInterestsTagsWeightEnum$outboundSchema: z.ZodNativeEnum<
  typeof SignalInterestsTagsWeightEnum
> = SignalInterestsTagsWeightEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SignalInterestsTagsWeightEnum$ {
  /** @deprecated use `SignalInterestsTagsWeightEnum$inboundSchema` instead. */
  export const inboundSchema = SignalInterestsTagsWeightEnum$inboundSchema;
  /** @deprecated use `SignalInterestsTagsWeightEnum$outboundSchema` instead. */
  export const outboundSchema = SignalInterestsTagsWeightEnum$outboundSchema;
}

/** @internal */
export const SignalInterestsTagsWeight$inboundSchema: z.ZodType<
  SignalInterestsTagsWeight,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), SignalInterestsTagsWeightEnum$inboundSchema]);

/** @internal */
export type SignalInterestsTagsWeight$Outbound = number | string;

/** @internal */
export const SignalInterestsTagsWeight$outboundSchema: z.ZodType<
  SignalInterestsTagsWeight$Outbound,
  z.ZodTypeDef,
  SignalInterestsTagsWeight
> = z.union([z.number(), SignalInterestsTagsWeightEnum$outboundSchema]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SignalInterestsTagsWeight$ {
  /** @deprecated use `SignalInterestsTagsWeight$inboundSchema` instead. */
  export const inboundSchema = SignalInterestsTagsWeight$inboundSchema;
  /** @deprecated use `SignalInterestsTagsWeight$outboundSchema` instead. */
  export const outboundSchema = SignalInterestsTagsWeight$outboundSchema;
  /** @deprecated use `SignalInterestsTagsWeight$Outbound` instead. */
  export type Outbound = SignalInterestsTagsWeight$Outbound;
}

export function signalInterestsTagsWeightToJSON(
  signalInterestsTagsWeight: SignalInterestsTagsWeight,
): string {
  return JSON.stringify(
    SignalInterestsTagsWeight$outboundSchema.parse(signalInterestsTagsWeight),
  );
}

export function signalInterestsTagsWeightFromJSON(
  jsonString: string,
): SafeParseResult<SignalInterestsTagsWeight, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SignalInterestsTagsWeight$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SignalInterestsTagsWeight' from JSON`,
  );
}

/** @internal */
export const SignalLocationWeightEnum$inboundSchema: z.ZodNativeEnum<
  typeof SignalLocationWeightEnum
> = z.nativeEnum(SignalLocationWeightEnum);

/** @internal */
export const SignalLocationWeightEnum$outboundSchema: z.ZodNativeEnum<
  typeof SignalLocationWeightEnum
> = SignalLocationWeightEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SignalLocationWeightEnum$ {
  /** @deprecated use `SignalLocationWeightEnum$inboundSchema` instead. */
  export const inboundSchema = SignalLocationWeightEnum$inboundSchema;
  /** @deprecated use `SignalLocationWeightEnum$outboundSchema` instead. */
  export const outboundSchema = SignalLocationWeightEnum$outboundSchema;
}

/** @internal */
export const SignalLocationWeight$inboundSchema: z.ZodType<
  SignalLocationWeight,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), SignalLocationWeightEnum$inboundSchema]);

/** @internal */
export type SignalLocationWeight$Outbound = number | string;

/** @internal */
export const SignalLocationWeight$outboundSchema: z.ZodType<
  SignalLocationWeight$Outbound,
  z.ZodTypeDef,
  SignalLocationWeight
> = z.union([z.number(), SignalLocationWeightEnum$outboundSchema]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SignalLocationWeight$ {
  /** @deprecated use `SignalLocationWeight$inboundSchema` instead. */
  export const inboundSchema = SignalLocationWeight$inboundSchema;
  /** @deprecated use `SignalLocationWeight$outboundSchema` instead. */
  export const outboundSchema = SignalLocationWeight$outboundSchema;
  /** @deprecated use `SignalLocationWeight$Outbound` instead. */
  export type Outbound = SignalLocationWeight$Outbound;
}

export function signalLocationWeightToJSON(
  signalLocationWeight: SignalLocationWeight,
): string {
  return JSON.stringify(
    SignalLocationWeight$outboundSchema.parse(signalLocationWeight),
  );
}

export function signalLocationWeightFromJSON(
  jsonString: string,
): SafeParseResult<SignalLocationWeight, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SignalLocationWeight$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SignalLocationWeight' from JSON`,
  );
}

/** @internal */
export const SortBy$inboundSchema: z.ZodNativeEnum<typeof SortBy> = z
  .nativeEnum(SortBy);

/** @internal */
export const SortBy$outboundSchema: z.ZodNativeEnum<typeof SortBy> =
  SortBy$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SortBy$ {
  /** @deprecated use `SortBy$inboundSchema` instead. */
  export const inboundSchema = SortBy$inboundSchema;
  /** @deprecated use `SortBy$outboundSchema` instead. */
  export const outboundSchema = SortBy$outboundSchema;
}

/** @internal */
export const GetInsightsRequest$inboundSchema: z.ZodType<
  GetInsightsRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  "filter.type": FilterType$inboundSchema,
  "bias.trends": BiasTrends$inboundSchema.optional(),
  "diversify.by": z.string().optional(),
  "diversify.take": z.number().int().optional(),
  "feature.explainability": z.boolean().default(false),
  "filter.address": z.string().optional(),
  "filter.content_rating": FilterContentRating$inboundSchema.optional(),
  "filter.date_of_birth.max": z.string().transform(v => new RFCDate(v))
    .optional(),
  "filter.date_of_birth.min": z.string().transform(v => new RFCDate(v))
    .optional(),
  "filter.date_of_death.max": z.string().transform(v => new RFCDate(v))
    .optional(),
  "filter.date_of_death.min": z.string().transform(v => new RFCDate(v))
    .optional(),
  "filter.exclude.tags": z.string().optional(),
  "operator.exclude.tags": OperatorExcludeTags$inboundSchema.optional(),
  "filter.exists": z.string().optional(),
  "filter.external.exists": z.string().optional(),
  "operator.filter.external.exists": OperatorFilterExternalExists$inboundSchema
    .optional(),
  "filter.external.resy.count.max": z.number().int().optional(),
  "filter.external.resy.count.min": z.number().int().optional(),
  "filter.external.resy.party_size.max": z.number().int().optional(),
  "filter.external.resy.party_size.min": z.number().int().optional(),
  "filter.external.resy.rating.max": z.number().optional(),
  "filter.external.resy.rating.min": z.number().optional(),
  "filter.external.tripadvisor.rating.count.min": z.number().int().optional(),
  "filter.external.tripadvisor.rating.count.max": z.number().int().optional(),
  "filter.external.tripadvisor.rating.max": z.number().optional(),
  "filter.external.tripadvisor.rating.min": z.number().optional(),
  "filter.finale_year.max": z.number().int().optional(),
  "filter.finale_year.min": z.number().int().optional(),
  "filter.gender": z.string().optional(),
  "filter.geocode.admin1_region": z.string().optional(),
  "filter.geocode.admin2_region": z.string().optional(),
  "filter.geocode.country_code": z.string().optional(),
  "filter.geocode.name": z.string().optional(),
  "filter.hotel_class.max": z.number().int().optional(),
  "filter.hotel_class.min": z.number().int().optional(),
  "filter.hours": FilterHours$inboundSchema.optional(),
  "filter.latest_known_year.max": z.number().int().optional(),
  "filter.latest_known_year.min": z.number().int().optional(),
  "filter.location": z.string().optional(),
  "filter.exclude.location": z.string().optional(),
  "filter.location.query": z.union([z.string(), z.array(z.string())])
    .optional(),
  "filter.exclude.location.query": z.union([z.string(), z.array(z.string())])
    .optional(),
  "filter.location.geohash": z.string().optional(),
  "filter.exclude.location.geohash": z.string().optional(),
  "filter.location.radius": z.number().int().default(15000),
  "filter.parents.types": z.array(z.string()).optional(),
  "filter.popularity.max": z.number().optional(),
  "filter.popularity.min": z.number().optional(),
  "filter.price_level.max": z.number().int().optional(),
  "filter.price_level.min": z.number().int().optional(),
  "filter.price_range.from": z.number().int().optional(),
  "filter.price_range.to": z.number().int().optional(),
  "filter.price.max": z.number().optional(),
  "filter.price.min": z.number().optional(),
  "filter.properties.business_rating.max": z.number().optional(),
  "filter.properties.business_rating.min": z.number().optional(),
  "filter.publication_year.max": z.number().optional(),
  "filter.publication_year.min": z.number().optional(),
  "filter.rating.max": z.number().optional(),
  "filter.rating.min": z.number().optional(),
  "filter.references_brand": z.array(z.string()).optional(),
  "filter.release_country": z.array(z.string()).optional(),
  "operator.filter.release_country": OperatorFilterReleaseCountry$inboundSchema
    .optional(),
  "filter.release_date.max": z.string().transform(v => new RFCDate(v))
    .optional(),
  "filter.release_date.min": z.string().transform(v => new RFCDate(v))
    .optional(),
  "filter.release_year.max": z.number().int().optional(),
  "filter.release_year.min": z.number().int().optional(),
  "filter.results.entities": z.string().optional(),
  "filter.results.entities.query": z.union([z.string(), z.array(z.string())])
    .optional(),
  "filter.exclude.entities": z.string().optional(),
  "filter.exclude.entities.query": z.array(
    z.union([
      z.lazy(() => FilterExcludeEntitiesQuery$inboundSchema),
      z.string(),
    ]),
  ).optional(),
  "filter.results.tags": z.array(z.string()).optional(),
  "filter.tags": z.string().optional(),
  "operator.filter.tags": OperatorFilterTags$inboundSchema.optional(),
  offset: z.number().int().optional(),
  "output.heatmap.boundary": z.string().optional(),
  page: z.number().int().optional(),
  "signal.demographics.age": SignalDemographicsAge$inboundSchema.optional(),
  "signal.demographics.age.weight": z.union([
    z.number(),
    SignalDemographicsAgeWeightEnum$inboundSchema,
  ]).optional(),
  "signal.demographics.audiences.weight": z.union([
    z.number(),
    SignalDemographicsAudiencesWeightEnum$inboundSchema,
  ]).optional(),
  "signal.demographics.audiences": z.array(z.string()).optional(),
  "signal.demographics.gender": SignalDemographicsGender$inboundSchema
    .optional(),
  "signal.demographics.gender.weight": z.union([
    z.number(),
    SignalDemographicsGenderWeightEnum$inboundSchema,
  ]).optional(),
  "signal.interests.entities": z.array(z.string()).optional(),
  "signal.interests.entities.query": z.array(
    z.union([
      z.lazy(() => SignalInterestsEntitiesQuery$inboundSchema),
      z.string(),
    ]),
  ).optional(),
  "signal.interests.entities.weight": z.union([
    z.number(),
    SignalInterestsEntitiesWeightEnum$inboundSchema,
  ]).optional(),
  "signal.interests.tags": z.union([
    z.array(z.string()),
    z.array(z.lazy(() => SignalInterestsTags$inboundSchema)),
  ]).optional(),
  "signal.interests.tags.weight": z.union([
    z.number(),
    SignalInterestsTagsWeightEnum$inboundSchema,
  ]).optional(),
  "signal.location": z.string().optional(),
  "signal.location.radius": z.number().int().optional(),
  "signal.location.query": z.string().optional(),
  "signal.location.weight": z.union([
    z.number(),
    SignalLocationWeightEnum$inboundSchema,
  ]).optional(),
  sort_by: SortBy$inboundSchema.optional(),
  take: z.number().int().optional(),
}).transform((v) => {
  return remap$(v, {
    "filter.type": "filterType",
    "bias.trends": "biasTrends",
    "diversify.by": "diversifyBy",
    "diversify.take": "diversifyTake",
    "feature.explainability": "featureExplainability",
    "filter.address": "filterAddress",
    "filter.content_rating": "filterContentRating",
    "filter.date_of_birth.max": "filterDateOfBirthMax",
    "filter.date_of_birth.min": "filterDateOfBirthMin",
    "filter.date_of_death.max": "filterDateOfDeathMax",
    "filter.date_of_death.min": "filterDateOfDeathMin",
    "filter.exclude.tags": "filterExcludeTags",
    "operator.exclude.tags": "operatorExcludeTags",
    "filter.exists": "filterExists",
    "filter.external.exists": "filterExternalExists",
    "operator.filter.external.exists": "operatorFilterExternalExists",
    "filter.external.resy.count.max": "filterExternalResyCountMax",
    "filter.external.resy.count.min": "filterExternalResyCountMin",
    "filter.external.resy.party_size.max": "filterExternalResyPartySizeMax",
    "filter.external.resy.party_size.min": "filterExternalResyPartySizeMin",
    "filter.external.resy.rating.max": "filterExternalResyRatingMax",
    "filter.external.resy.rating.min": "filterExternalResyRatingMin",
    "filter.external.tripadvisor.rating.count.min":
      "filterExternalTripadvisorRatingCountMin",
    "filter.external.tripadvisor.rating.count.max":
      "filterExternalTripadvisorRatingCountMax",
    "filter.external.tripadvisor.rating.max":
      "filterExternalTripadvisorRatingMax",
    "filter.external.tripadvisor.rating.min":
      "filterExternalTripadvisorRatingMin",
    "filter.finale_year.max": "filterFinaleYearMax",
    "filter.finale_year.min": "filterFinaleYearMin",
    "filter.gender": "filterGender",
    "filter.geocode.admin1_region": "filterGeocodeAdmin1Region",
    "filter.geocode.admin2_region": "filterGeocodeAdmin2Region",
    "filter.geocode.country_code": "filterGeocodeCountryCode",
    "filter.geocode.name": "filterGeocodeName",
    "filter.hotel_class.max": "filterHotelClassMax",
    "filter.hotel_class.min": "filterHotelClassMin",
    "filter.hours": "filterHours",
    "filter.latest_known_year.max": "filterLatestKnownYearMax",
    "filter.latest_known_year.min": "filterLatestKnownYearMin",
    "filter.location": "filterLocation",
    "filter.exclude.location": "filterExcludeLocation",
    "filter.location.query": "filterLocationQuery",
    "filter.exclude.location.query": "filterExcludeLocationQuery",
    "filter.location.geohash": "filterLocationGeohash",
    "filter.exclude.location.geohash": "filterExcludeLocationGeohash",
    "filter.location.radius": "filterLocationRadius",
    "filter.parents.types": "filterParentsTypes",
    "filter.popularity.max": "filterPopularityMax",
    "filter.popularity.min": "filterPopularityMin",
    "filter.price_level.max": "filterPriceLevelMax",
    "filter.price_level.min": "filterPriceLevelMin",
    "filter.price_range.from": "filterPriceRangeFrom",
    "filter.price_range.to": "filterPriceRangeTo",
    "filter.price.max": "filterPriceMax",
    "filter.price.min": "filterPriceMin",
    "filter.properties.business_rating.max":
      "filterPropertiesBusinessRatingMax",
    "filter.properties.business_rating.min":
      "filterPropertiesBusinessRatingMin",
    "filter.publication_year.max": "filterPublicationYearMax",
    "filter.publication_year.min": "filterPublicationYearMin",
    "filter.rating.max": "filterRatingMax",
    "filter.rating.min": "filterRatingMin",
    "filter.references_brand": "filterReferencesBrand",
    "filter.release_country": "filterReleaseCountry",
    "operator.filter.release_country": "operatorFilterReleaseCountry",
    "filter.release_date.max": "filterReleaseDateMax",
    "filter.release_date.min": "filterReleaseDateMin",
    "filter.release_year.max": "filterReleaseYearMax",
    "filter.release_year.min": "filterReleaseYearMin",
    "filter.results.entities": "filterResultsEntities",
    "filter.results.entities.query": "filterResultsEntitiesQuery",
    "filter.exclude.entities": "filterExcludeEntities",
    "filter.exclude.entities.query": "filterExcludeEntitiesQuery",
    "filter.results.tags": "filterResultsTags",
    "filter.tags": "filterTags",
    "operator.filter.tags": "operatorFilterTags",
    "output.heatmap.boundary": "outputHeatmapBoundary",
    "signal.demographics.age": "signalDemographicsAge",
    "signal.demographics.age.weight": "signalDemographicsAgeWeight",
    "signal.demographics.audiences.weight": "signalDemographicsAudiencesWeight",
    "signal.demographics.audiences": "signalDemographicsAudiences",
    "signal.demographics.gender": "signalDemographicsGender",
    "signal.demographics.gender.weight": "signalDemographicsGenderWeight",
    "signal.interests.entities": "signalInterestsEntities",
    "signal.interests.entities.query": "signalInterestsEntitiesQuery",
    "signal.interests.entities.weight": "signalInterestsEntitiesWeight",
    "signal.interests.tags": "signalInterestsTags",
    "signal.interests.tags.weight": "signalInterestsTagsWeight",
    "signal.location": "signalLocation",
    "signal.location.radius": "signalLocationRadius",
    "signal.location.query": "signalLocationQuery",
    "signal.location.weight": "signalLocationWeight",
    "sort_by": "sortBy",
  });
});

/** @internal */
export type GetInsightsRequest$Outbound = {
  "filter.type": string;
  "bias.trends"?: string | undefined;
  "diversify.by"?: string | undefined;
  "diversify.take"?: number | undefined;
  "feature.explainability": boolean;
  "filter.address"?: string | undefined;
  "filter.content_rating"?: string | undefined;
  "filter.date_of_birth.max"?: string | undefined;
  "filter.date_of_birth.min"?: string | undefined;
  "filter.date_of_death.max"?: string | undefined;
  "filter.date_of_death.min"?: string | undefined;
  "filter.exclude.tags"?: string | undefined;
  "operator.exclude.tags"?: string | undefined;
  "filter.exists"?: string | undefined;
  "filter.external.exists"?: string | undefined;
  "operator.filter.external.exists"?: string | undefined;
  "filter.external.resy.count.max"?: number | undefined;
  "filter.external.resy.count.min"?: number | undefined;
  "filter.external.resy.party_size.max"?: number | undefined;
  "filter.external.resy.party_size.min"?: number | undefined;
  "filter.external.resy.rating.max"?: number | undefined;
  "filter.external.resy.rating.min"?: number | undefined;
  "filter.external.tripadvisor.rating.count.min"?: number | undefined;
  "filter.external.tripadvisor.rating.count.max"?: number | undefined;
  "filter.external.tripadvisor.rating.max"?: number | undefined;
  "filter.external.tripadvisor.rating.min"?: number | undefined;
  "filter.finale_year.max"?: number | undefined;
  "filter.finale_year.min"?: number | undefined;
  "filter.gender"?: string | undefined;
  "filter.geocode.admin1_region"?: string | undefined;
  "filter.geocode.admin2_region"?: string | undefined;
  "filter.geocode.country_code"?: string | undefined;
  "filter.geocode.name"?: string | undefined;
  "filter.hotel_class.max"?: number | undefined;
  "filter.hotel_class.min"?: number | undefined;
  "filter.hours"?: string | undefined;
  "filter.latest_known_year.max"?: number | undefined;
  "filter.latest_known_year.min"?: number | undefined;
  "filter.location"?: string | undefined;
  "filter.exclude.location"?: string | undefined;
  "filter.location.query"?: string | Array<string> | undefined;
  "filter.exclude.location.query"?: string | Array<string> | undefined;
  "filter.location.geohash"?: string | undefined;
  "filter.exclude.location.geohash"?: string | undefined;
  "filter.location.radius": number;
  "filter.parents.types"?: Array<string> | undefined;
  "filter.popularity.max"?: number | undefined;
  "filter.popularity.min"?: number | undefined;
  "filter.price_level.max"?: number | undefined;
  "filter.price_level.min"?: number | undefined;
  "filter.price_range.from"?: number | undefined;
  "filter.price_range.to"?: number | undefined;
  "filter.price.max"?: number | undefined;
  "filter.price.min"?: number | undefined;
  "filter.properties.business_rating.max"?: number | undefined;
  "filter.properties.business_rating.min"?: number | undefined;
  "filter.publication_year.max"?: number | undefined;
  "filter.publication_year.min"?: number | undefined;
  "filter.rating.max"?: number | undefined;
  "filter.rating.min"?: number | undefined;
  "filter.references_brand"?: Array<string> | undefined;
  "filter.release_country"?: Array<string> | undefined;
  "operator.filter.release_country"?: string | undefined;
  "filter.release_date.max"?: string | undefined;
  "filter.release_date.min"?: string | undefined;
  "filter.release_year.max"?: number | undefined;
  "filter.release_year.min"?: number | undefined;
  "filter.results.entities"?: string | undefined;
  "filter.results.entities.query"?: string | Array<string> | undefined;
  "filter.exclude.entities"?: string | undefined;
  "filter.exclude.entities.query"?:
    | Array<FilterExcludeEntitiesQuery$Outbound | string>
    | undefined;
  "filter.results.tags"?: Array<string> | undefined;
  "filter.tags"?: string | undefined;
  "operator.filter.tags"?: string | undefined;
  offset?: number | undefined;
  "output.heatmap.boundary"?: string | undefined;
  page?: number | undefined;
  "signal.demographics.age"?: string | undefined;
  "signal.demographics.age.weight"?: number | string | undefined;
  "signal.demographics.audiences.weight"?: number | string | undefined;
  "signal.demographics.audiences"?: Array<string> | undefined;
  "signal.demographics.gender"?: string | undefined;
  "signal.demographics.gender.weight"?: number | string | undefined;
  "signal.interests.entities"?: Array<string> | undefined;
  "signal.interests.entities.query"?:
    | Array<SignalInterestsEntitiesQuery$Outbound | string>
    | undefined;
  "signal.interests.entities.weight"?: number | string | undefined;
  "signal.interests.tags"?:
    | Array<string>
    | Array<SignalInterestsTags$Outbound>
    | undefined;
  "signal.interests.tags.weight"?: number | string | undefined;
  "signal.location"?: string | undefined;
  "signal.location.radius"?: number | undefined;
  "signal.location.query"?: string | undefined;
  "signal.location.weight"?: number | string | undefined;
  sort_by?: string | undefined;
  take?: number | undefined;
};

/** @internal */
export const GetInsightsRequest$outboundSchema: z.ZodType<
  GetInsightsRequest$Outbound,
  z.ZodTypeDef,
  GetInsightsRequest
> = z.object({
  filterType: FilterType$outboundSchema,
  biasTrends: BiasTrends$outboundSchema.optional(),
  diversifyBy: z.string().optional(),
  diversifyTake: z.number().int().optional(),
  featureExplainability: z.boolean().default(false),
  filterAddress: z.string().optional(),
  filterContentRating: FilterContentRating$outboundSchema.optional(),
  filterDateOfBirthMax: z.instanceof(RFCDate).transform(v => v.toString())
    .optional(),
  filterDateOfBirthMin: z.instanceof(RFCDate).transform(v => v.toString())
    .optional(),
  filterDateOfDeathMax: z.instanceof(RFCDate).transform(v => v.toString())
    .optional(),
  filterDateOfDeathMin: z.instanceof(RFCDate).transform(v => v.toString())
    .optional(),
  filterExcludeTags: z.string().optional(),
  operatorExcludeTags: OperatorExcludeTags$outboundSchema.optional(),
  filterExists: z.string().optional(),
  filterExternalExists: z.string().optional(),
  operatorFilterExternalExists: OperatorFilterExternalExists$outboundSchema
    .optional(),
  filterExternalResyCountMax: z.number().int().optional(),
  filterExternalResyCountMin: z.number().int().optional(),
  filterExternalResyPartySizeMax: z.number().int().optional(),
  filterExternalResyPartySizeMin: z.number().int().optional(),
  filterExternalResyRatingMax: z.number().optional(),
  filterExternalResyRatingMin: z.number().optional(),
  filterExternalTripadvisorRatingCountMin: z.number().int().optional(),
  filterExternalTripadvisorRatingCountMax: z.number().int().optional(),
  filterExternalTripadvisorRatingMax: z.number().optional(),
  filterExternalTripadvisorRatingMin: z.number().optional(),
  filterFinaleYearMax: z.number().int().optional(),
  filterFinaleYearMin: z.number().int().optional(),
  filterGender: z.string().optional(),
  filterGeocodeAdmin1Region: z.string().optional(),
  filterGeocodeAdmin2Region: z.string().optional(),
  filterGeocodeCountryCode: z.string().optional(),
  filterGeocodeName: z.string().optional(),
  filterHotelClassMax: z.number().int().optional(),
  filterHotelClassMin: z.number().int().optional(),
  filterHours: FilterHours$outboundSchema.optional(),
  filterLatestKnownYearMax: z.number().int().optional(),
  filterLatestKnownYearMin: z.number().int().optional(),
  filterLocation: z.string().optional(),
  filterExcludeLocation: z.string().optional(),
  filterLocationQuery: z.union([z.string(), z.array(z.string())]).optional(),
  filterExcludeLocationQuery: z.union([z.string(), z.array(z.string())])
    .optional(),
  filterLocationGeohash: z.string().optional(),
  filterExcludeLocationGeohash: z.string().optional(),
  filterLocationRadius: z.number().int().default(15000),
  filterParentsTypes: z.array(z.string()).optional(),
  filterPopularityMax: z.number().optional(),
  filterPopularityMin: z.number().optional(),
  filterPriceLevelMax: z.number().int().optional(),
  filterPriceLevelMin: z.number().int().optional(),
  filterPriceRangeFrom: z.number().int().optional(),
  filterPriceRangeTo: z.number().int().optional(),
  filterPriceMax: z.number().optional(),
  filterPriceMin: z.number().optional(),
  filterPropertiesBusinessRatingMax: z.number().optional(),
  filterPropertiesBusinessRatingMin: z.number().optional(),
  filterPublicationYearMax: z.number().optional(),
  filterPublicationYearMin: z.number().optional(),
  filterRatingMax: z.number().optional(),
  filterRatingMin: z.number().optional(),
  filterReferencesBrand: z.array(z.string()).optional(),
  filterReleaseCountry: z.array(z.string()).optional(),
  operatorFilterReleaseCountry: OperatorFilterReleaseCountry$outboundSchema
    .optional(),
  filterReleaseDateMax: z.instanceof(RFCDate).transform(v => v.toString())
    .optional(),
  filterReleaseDateMin: z.instanceof(RFCDate).transform(v => v.toString())
    .optional(),
  filterReleaseYearMax: z.number().int().optional(),
  filterReleaseYearMin: z.number().int().optional(),
  filterResultsEntities: z.string().optional(),
  filterResultsEntitiesQuery: z.union([z.string(), z.array(z.string())])
    .optional(),
  filterExcludeEntities: z.string().optional(),
  filterExcludeEntitiesQuery: z.array(
    z.union([
      z.lazy(() => FilterExcludeEntitiesQuery$outboundSchema),
      z.string(),
    ]),
  ).optional(),
  filterResultsTags: z.array(z.string()).optional(),
  filterTags: z.string().optional(),
  operatorFilterTags: OperatorFilterTags$outboundSchema.optional(),
  offset: z.number().int().optional(),
  outputHeatmapBoundary: z.string().optional(),
  page: z.number().int().optional(),
  signalDemographicsAge: SignalDemographicsAge$outboundSchema.optional(),
  signalDemographicsAgeWeight: z.union([
    z.number(),
    SignalDemographicsAgeWeightEnum$outboundSchema,
  ]).optional(),
  signalDemographicsAudiencesWeight: z.union([
    z.number(),
    SignalDemographicsAudiencesWeightEnum$outboundSchema,
  ]).optional(),
  signalDemographicsAudiences: z.array(z.string()).optional(),
  signalDemographicsGender: SignalDemographicsGender$outboundSchema.optional(),
  signalDemographicsGenderWeight: z.union([
    z.number(),
    SignalDemographicsGenderWeightEnum$outboundSchema,
  ]).optional(),
  signalInterestsEntities: z.array(z.string()).optional(),
  signalInterestsEntitiesQuery: z.array(
    z.union([
      z.lazy(() => SignalInterestsEntitiesQuery$outboundSchema),
      z.string(),
    ]),
  ).optional(),
  signalInterestsEntitiesWeight: z.union([
    z.number(),
    SignalInterestsEntitiesWeightEnum$outboundSchema,
  ]).optional(),
  signalInterestsTags: z.union([
    z.array(z.string()),
    z.array(z.lazy(() => SignalInterestsTags$outboundSchema)),
  ]).optional(),
  signalInterestsTagsWeight: z.union([
    z.number(),
    SignalInterestsTagsWeightEnum$outboundSchema,
  ]).optional(),
  signalLocation: z.string().optional(),
  signalLocationRadius: z.number().int().optional(),
  signalLocationQuery: z.string().optional(),
  signalLocationWeight: z.union([
    z.number(),
    SignalLocationWeightEnum$outboundSchema,
  ]).optional(),
  sortBy: SortBy$outboundSchema.optional(),
  take: z.number().int().optional(),
}).transform((v) => {
  return remap$(v, {
    filterType: "filter.type",
    biasTrends: "bias.trends",
    diversifyBy: "diversify.by",
    diversifyTake: "diversify.take",
    featureExplainability: "feature.explainability",
    filterAddress: "filter.address",
    filterContentRating: "filter.content_rating",
    filterDateOfBirthMax: "filter.date_of_birth.max",
    filterDateOfBirthMin: "filter.date_of_birth.min",
    filterDateOfDeathMax: "filter.date_of_death.max",
    filterDateOfDeathMin: "filter.date_of_death.min",
    filterExcludeTags: "filter.exclude.tags",
    operatorExcludeTags: "operator.exclude.tags",
    filterExists: "filter.exists",
    filterExternalExists: "filter.external.exists",
    operatorFilterExternalExists: "operator.filter.external.exists",
    filterExternalResyCountMax: "filter.external.resy.count.max",
    filterExternalResyCountMin: "filter.external.resy.count.min",
    filterExternalResyPartySizeMax: "filter.external.resy.party_size.max",
    filterExternalResyPartySizeMin: "filter.external.resy.party_size.min",
    filterExternalResyRatingMax: "filter.external.resy.rating.max",
    filterExternalResyRatingMin: "filter.external.resy.rating.min",
    filterExternalTripadvisorRatingCountMin:
      "filter.external.tripadvisor.rating.count.min",
    filterExternalTripadvisorRatingCountMax:
      "filter.external.tripadvisor.rating.count.max",
    filterExternalTripadvisorRatingMax:
      "filter.external.tripadvisor.rating.max",
    filterExternalTripadvisorRatingMin:
      "filter.external.tripadvisor.rating.min",
    filterFinaleYearMax: "filter.finale_year.max",
    filterFinaleYearMin: "filter.finale_year.min",
    filterGender: "filter.gender",
    filterGeocodeAdmin1Region: "filter.geocode.admin1_region",
    filterGeocodeAdmin2Region: "filter.geocode.admin2_region",
    filterGeocodeCountryCode: "filter.geocode.country_code",
    filterGeocodeName: "filter.geocode.name",
    filterHotelClassMax: "filter.hotel_class.max",
    filterHotelClassMin: "filter.hotel_class.min",
    filterHours: "filter.hours",
    filterLatestKnownYearMax: "filter.latest_known_year.max",
    filterLatestKnownYearMin: "filter.latest_known_year.min",
    filterLocation: "filter.location",
    filterExcludeLocation: "filter.exclude.location",
    filterLocationQuery: "filter.location.query",
    filterExcludeLocationQuery: "filter.exclude.location.query",
    filterLocationGeohash: "filter.location.geohash",
    filterExcludeLocationGeohash: "filter.exclude.location.geohash",
    filterLocationRadius: "filter.location.radius",
    filterParentsTypes: "filter.parents.types",
    filterPopularityMax: "filter.popularity.max",
    filterPopularityMin: "filter.popularity.min",
    filterPriceLevelMax: "filter.price_level.max",
    filterPriceLevelMin: "filter.price_level.min",
    filterPriceRangeFrom: "filter.price_range.from",
    filterPriceRangeTo: "filter.price_range.to",
    filterPriceMax: "filter.price.max",
    filterPriceMin: "filter.price.min",
    filterPropertiesBusinessRatingMax: "filter.properties.business_rating.max",
    filterPropertiesBusinessRatingMin: "filter.properties.business_rating.min",
    filterPublicationYearMax: "filter.publication_year.max",
    filterPublicationYearMin: "filter.publication_year.min",
    filterRatingMax: "filter.rating.max",
    filterRatingMin: "filter.rating.min",
    filterReferencesBrand: "filter.references_brand",
    filterReleaseCountry: "filter.release_country",
    operatorFilterReleaseCountry: "operator.filter.release_country",
    filterReleaseDateMax: "filter.release_date.max",
    filterReleaseDateMin: "filter.release_date.min",
    filterReleaseYearMax: "filter.release_year.max",
    filterReleaseYearMin: "filter.release_year.min",
    filterResultsEntities: "filter.results.entities",
    filterResultsEntitiesQuery: "filter.results.entities.query",
    filterExcludeEntities: "filter.exclude.entities",
    filterExcludeEntitiesQuery: "filter.exclude.entities.query",
    filterResultsTags: "filter.results.tags",
    filterTags: "filter.tags",
    operatorFilterTags: "operator.filter.tags",
    outputHeatmapBoundary: "output.heatmap.boundary",
    signalDemographicsAge: "signal.demographics.age",
    signalDemographicsAgeWeight: "signal.demographics.age.weight",
    signalDemographicsAudiencesWeight: "signal.demographics.audiences.weight",
    signalDemographicsAudiences: "signal.demographics.audiences",
    signalDemographicsGender: "signal.demographics.gender",
    signalDemographicsGenderWeight: "signal.demographics.gender.weight",
    signalInterestsEntities: "signal.interests.entities",
    signalInterestsEntitiesQuery: "signal.interests.entities.query",
    signalInterestsEntitiesWeight: "signal.interests.entities.weight",
    signalInterestsTags: "signal.interests.tags",
    signalInterestsTagsWeight: "signal.interests.tags.weight",
    signalLocation: "signal.location",
    signalLocationRadius: "signal.location.radius",
    signalLocationQuery: "signal.location.query",
    signalLocationWeight: "signal.location.weight",
    sortBy: "sort_by",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetInsightsRequest$ {
  /** @deprecated use `GetInsightsRequest$inboundSchema` instead. */
  export const inboundSchema = GetInsightsRequest$inboundSchema;
  /** @deprecated use `GetInsightsRequest$outboundSchema` instead. */
  export const outboundSchema = GetInsightsRequest$outboundSchema;
  /** @deprecated use `GetInsightsRequest$Outbound` instead. */
  export type Outbound = GetInsightsRequest$Outbound;
}

export function getInsightsRequestToJSON(
  getInsightsRequest: GetInsightsRequest,
): string {
  return JSON.stringify(
    GetInsightsRequest$outboundSchema.parse(getInsightsRequest),
  );
}

export function getInsightsRequestFromJSON(
  jsonString: string,
): SafeParseResult<GetInsightsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetInsightsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetInsightsRequest' from JSON`,
  );
}

/** @internal */
export const GetInsightsResults$inboundSchema: z.ZodType<
  GetInsightsResults,
  z.ZodTypeDef,
  unknown
> = z.object({
  entities: z.array(z.any()).optional(),
  duration: z.number().optional(),
});

/** @internal */
export type GetInsightsResults$Outbound = {
  entities?: Array<any> | undefined;
  duration?: number | undefined;
};

/** @internal */
export const GetInsightsResults$outboundSchema: z.ZodType<
  GetInsightsResults$Outbound,
  z.ZodTypeDef,
  GetInsightsResults
> = z.object({
  entities: z.array(z.any()).optional(),
  duration: z.number().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetInsightsResults$ {
  /** @deprecated use `GetInsightsResults$inboundSchema` instead. */
  export const inboundSchema = GetInsightsResults$inboundSchema;
  /** @deprecated use `GetInsightsResults$outboundSchema` instead. */
  export const outboundSchema = GetInsightsResults$outboundSchema;
  /** @deprecated use `GetInsightsResults$Outbound` instead. */
  export type Outbound = GetInsightsResults$Outbound;
}

export function getInsightsResultsToJSON(
  getInsightsResults: GetInsightsResults,
): string {
  return JSON.stringify(
    GetInsightsResults$outboundSchema.parse(getInsightsResults),
  );
}

export function getInsightsResultsFromJSON(
  jsonString: string,
): SafeParseResult<GetInsightsResults, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetInsightsResults$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetInsightsResults' from JSON`,
  );
}

/** @internal */
export const GetInsightsResponse$inboundSchema: z.ZodType<
  GetInsightsResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  success: z.boolean().optional(),
  results: z.lazy(() => GetInsightsResults$inboundSchema).optional(),
});

/** @internal */
export type GetInsightsResponse$Outbound = {
  success?: boolean | undefined;
  results?: GetInsightsResults$Outbound | undefined;
};

/** @internal */
export const GetInsightsResponse$outboundSchema: z.ZodType<
  GetInsightsResponse$Outbound,
  z.ZodTypeDef,
  GetInsightsResponse
> = z.object({
  success: z.boolean().optional(),
  results: z.lazy(() => GetInsightsResults$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetInsightsResponse$ {
  /** @deprecated use `GetInsightsResponse$inboundSchema` instead. */
  export const inboundSchema = GetInsightsResponse$inboundSchema;
  /** @deprecated use `GetInsightsResponse$outboundSchema` instead. */
  export const outboundSchema = GetInsightsResponse$outboundSchema;
  /** @deprecated use `GetInsightsResponse$Outbound` instead. */
  export type Outbound = GetInsightsResponse$Outbound;
}

export function getInsightsResponseToJSON(
  getInsightsResponse: GetInsightsResponse,
): string {
  return JSON.stringify(
    GetInsightsResponse$outboundSchema.parse(getInsightsResponse),
  );
}

export function getInsightsResponseFromJSON(
  jsonString: string,
): SafeParseResult<GetInsightsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetInsightsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetInsightsResponse' from JSON`,
  );
}
